[[Fishing/First_Sem_Master_1/数大/数大|数大]]
## 一、引言
## 1. 数字处理器简介
对![[support/img/Pasted image 20231227111736.png#right|数字处理器|200]]应教材第八章开始的引言部分. 处理器是电子设备的大脑,这个大脑包含以下的几个主要部分
1. 数据通路: 
	1. 处理器的核心, 完成所有计算的场所. 
	2. 其他的模块是支持单元, 要么存储数据通路产生的结果, 要么帮助确定下一周期做什么. 
	3. 一个典型的数据通路包括逻辑运算和算术运算等基本功能的组合. 
	4. 中间结果放在寄存器
2. 控制模块:
	1. 决定了任何时刻,处理器中进行的操作是什么. 
	2. 一个控制器可以看做一个FSM.
	3. 由寄存器和组合逻辑组成, 是一个时序电路.
3. 存储模块
	1. 集中的数据存储区域, 一个处理器可以有很多不同类型的存储器.
	2. 主要按照数据的存取方式分类, 例如只读和只写等等.
	3. 另一种区分方法是数据保存能力, 分为动态存储器和静态存储器.<span style="background:#affad1">还有非易失性存储器.</span>
4. 互联网络
	1. IO是把芯片和外部相连,而互联网络是内部互联.
## 2. 数字处理器的数据通路
### (1)位片式（Bit-Sliced）数据通路
数据通路常常组织为位片式, 因为不是对bit进行操作, 通常是对word进行操作.

> 通常为32位或者64为, 在信号处理的数据通路一般为5~24位.

因此必须频繁的对每一位进行相同的操作, 因此数据通路有32个位片, 一个位片对一位进行操作, 称为位片式（Bit-Sliced）.这样的好处是, 减少了设计的复杂性.![[support/img/Pasted image 20231227112225.png|400]]
# 二、加法器
## 1. 全加器综述
### (1)全加器的真值表和电路符号
模样:  三个输入, 两个输出. 样子, 如下
![[support/img/Pasted image 20231227112309.png|200]]
真值表:
![[support/img/Pasted image 20231227112407.png|400]]
> delete,propagate,generate的含义:  
> 1. delete: 无论你$C_i$是什么, $C_o$都是0. 当然, 对应的就是A=B=0的情况
> 2. propagate: 对应AB之中有且只有一个是1的情况, 此时理所当然有$C_o=C_i$
> 3. generate: 对应A=B=1, 无论你$C_i$是什么, $C_o$都是1
### (2)全加器的逻辑表达式和GDP化简
原始表达式为:$$\begin{aligned}
&\mathbf{S}=A\oplus\mathbf{B}\oplus\mathbf{C}_{i}=A\overline{\boldsymbol{B}}\overline{\boldsymbol{C}}_{i}+\overline{A}\boldsymbol{B}\overline{\boldsymbol{C}}_{i}+\overline{A}\overline{\boldsymbol{B}}\boldsymbol{C}_{i}+A\boldsymbol{B}\boldsymbol{C}_{i} \\
&C_{_o}=AB+BC_{_i}+AC_{_i}
\end{aligned}$$
由于刚刚定义了GDP, 那么就把这三个信号表达出来:$$\begin{aligned}&\boldsymbol{G}=A\boldsymbol{B}\\\boldsymbol{D}&=\overline{\boldsymbol{A}}\overline{\boldsymbol{B}}\\\boldsymbol{P}&=A\oplus\boldsymbol{B}\quad(\quad\text{或}\quad\boldsymbol{P}=\boldsymbol{A}+\boldsymbol{B}\quad)\end{aligned}$$
用中间信号表示$C_o$和$S$:
$$\begin{aligned}&C_o(G,P)=G+PC_i\\&S(G,P)=P\oplus C_i\end{aligned}$$
==第一个式子表明: 进位可通过自己产生(G)或者通过传递上一位的进位来产生(PC)==
### (3)4 位逐位进位加法器（Ripple-Carry Adder行波加法器）
这就是最简单的结构, 把4个FA串联起来了, 称之为行波的原因是, 进位信号从第一级波动到最后一级.
#### A:延时分析
该电路的延时与下列两个因素有关
1. 传播必须通过的级数
2. 输入信号  
> 和输入信号有关必须要搞懂: 因为有的信号完全不会产生进位, 有些信号从最低有效位一直波动到最高有效位.  

这样一个结构也称为<font color="#ff0000">关键路径</font>, 其传播延时定义为: <u>对所有可能得输入情况, 在最坏可能下的延时.</u>  
#### B: 关键路径
最坏情况为: 最低有效位的进位一直波动到最高有效位. 
==这一进位在最后一级被吸收, 产生和==, 因此延时为:$$t_{adder}\approx(N-1)t_{carry}+\max(t_{sum},t_{carry})$$
其中
- $t_{carry}$是$C_i$到$C_o$的传播延时
- $t_{sum}$是$C_i$到$S$的传播延时
#### C: 全加器的反向特性
所有的输入反相, 则所有的输出也反相,表达式为:
$$\overline{S}(A,B,C_i)=S(\overline{A},\overline{B},\overline{C}_i)$$
$$\overline{C}_o(A,B,C_i)=C_o(\overline{A},\overline{B},\overline{C}_i)$$

==该表达式的意思是, 括号外反向, 等于括号里边所有的反向.==

## 2. 电路级设计
### (1)静态加法器电路
- 最直接的方法: 把逻辑表达式直接按之前的方法变为互补CMOS电路.
- 稍微思考一下: 由于主要进行的是carry延时的优化, 因此可以进行逻辑上的优化, 只要不影响carry信号的产生, 共享某些子电路可以减少晶体管的数量. 因此有如下的逻辑化简: $$\begin{array}{l}C_o=AB+BC_i+AC_i=AB+C_i(A+B)\\S=A\overline{B}\overline{C}_i+\overline{A}B\overline{C}_i+\overline{A}\overline{B}C_i+ABC_i=ABC_i+\overline{C}_o(A+B+C_i)\end{array}$$
根据这个逻辑表达式, 利用互补CMOS能直接画以下电路![[support/img/Pasted image 20231227120915.png]]
#### A: 聪明的地方
1. 进位产生电路之中, 把$C_i$信号放在了串联数较少的PMOS之路上,使得逻辑努力降低为2.
	1. 什么叫把$C_i$信号放在了串联数较少的PMOS之路上: 这一步是在化简$C_o$信号的时候, 因为原始的表达式是:$C_o=AB+BC_i+AC_i$, 由于三个是等价的,因此有三种化简方法:$AB+C_i(A+B)$、$AC_i+B(A+C_i)$、$BC_i+A(B+C_i)$.那么为什么选择第一个, 而不是选择第二个和第三个呢?
	2. 这就是涉及到逻辑努力的部分了, 由于要减少$C_i$输入端的逻辑努力, 那么你看看根据INV上2下1的参考标准, 有下图:![[support/img/Pasted image 20231227122214.png]]
	   这就有了$C_i$信号的逻辑努力为4+2=6,但是A为16,B为16. 所以有了第一个聪明的地方.
2. 连接到$C_i$的NMOS和PMOS尽可能放在靠近输出端的地方
> 解释如下:  
> 例如, 在第K级,$C_i$到达之前, A和B已经到达了, 因此晶体管链中的<font color="#ff0000">内部电容已经被预充或者放电了</font>, 因此C到达的时候只需要冲或者放X节点的电容. 但是要是放在靠近VDD或者GND的时候, 相当于C不来的时候, 通路在放电的终点就被截断了, 因此不仅需要放电X, 还需要放电内部节点.所以在某种意义上可以说是,远离GND和VDD,也就是靠近输出端.

#### B: 不聪明的地方
1. 进位产生、和产生电路之中**堆叠着PMOS管**.有关堆叠的问题,请详细参见[[Fishing/First_Sem_Master_1/数大/L11/L11_L12_SUPPLY#堆叠|L11_L12_SUPPLY_堆叠]]
2. $C_o$信号的本征负载电容很大, 包括两个负载电容和六个栅电容以及布线电容, 详细有关MOS电容,请参见[[Fishing/First_Sem_Master_1/数大/L11/L11_L12_SUPPLY#MOS电容|L11_L12_SUPPLY]]
3. 进位产⽣电路中信号传播通过两个反相级。正如前⾯提到的，最⼩化进位路径的延时是 ⾼速加法器电路设计者的⾸要⽇标。<span style="background:#affad1">如果进位链输出上的负载(扇出）很⼩，那么有两个逻辑级就显得太多，因⽽引起额外的延时。</span>(这里的意思是,第一级为那个Logic effort为2的那个组合门, 第二个就是把非变为不是非得那个反相器)
#### C: 特征
- 和的产⽣要求⼀个额外的逻辑级，但这并不那么重要，因为这⼀项在逐位进位加法器的传播延时公式（11.4)中只出现⼀次。
#### D: 利用反向特性进行改进
![[support/img/Pasted image 20231227153624.png]]
<font color="#ff0000">这里用面积(输入端A,B的反相器)换取了进位链上的反相器数量的减少</font>, 少了进位连全部的第二级反相级
### (2)镜像加法器(mirror adde)
![[support/img/Pasted image 20231227154904.png]]
#### A: 设计思路
在前后两级上, 运用了共享公共部分的思路.  
在进位产生电路上, 运用了GDP的思路.
- 首先看进位产生电路中的<font color="#ff0000">右侧的一列</font>, 这一列的作用是D和G, AB皆为0, 输出为1, 反之, ~~而前边的一列不会影像输出,因为左侧一列的AB部分肯定不会导通.~~
- 当A和B其中一个为0,其中一个为1的时候, 左侧一列的AB部分肯定会导通, 就看Ci是什么了.这就实现了P的功能, 而右侧那一列又不会影响输出.
在和产生电路上, 首先复用了进位产生电路的结果, 一样的思路, 左侧一列传播$C_o$, 右侧的一列输入全为0的时候, 输出为1, 反之. 因为表达式都符合下面这个形式: $$\begin{aligned}C_o&=AB+C_i(A+B)\\S&=ABC_i+\overline C_o(A+B+C_i)\end{aligned}$$
#### B:特点
1. 消除了进位输出的反相门。(其实不是这个的特点, 是因为反向特性)
2. 巧妙实现进位“传播/产生/ 消除”功能，同时减少面积和延时。
3. 不同于传统的“对偶”拓扑，而是“对称”或“镜像”，有利于版图实现。选择合适的P管和管的尺寸，可保证相同的上升和下降时间。
4. 在产生进位的电路部分，最多有两个管子串联。
5. 共24 个管子。（<span style="background:#d3f8b6">进位输出、和位输出均为反向??????那是你的作用吗哥们）</span>
6. 接$C_i$的晶体管放在最接近门的输出端处。
7. $C_o$节点上的电容包括本级的四个扩散电容和两个栅电容，以及下一级加法器的六个栅电容。<span style="background:#d3f8b6">减少扩散电容特别重要。</span>
8. 只有在产生进位的电路部分中，管子需要优化尺寸以改善速度， 在产生“和”位的电路部分，管子可以采用最小尺寸。![[support/img/Pasted image 20231227161204.png]]
>  对于8的解释  
> 1. 他所说的11.4是![[support/img/Pasted image 20231227161243.png]]
>    在这个图之中, 由于X连了一个**反相器**当做$C_o$输出,因此说以独⽴确定反**相器**的尺⼨来驱动下⼀级加法器的$C_i$输入。
> 2. 如果图11.6中的进位电路尺寸对称，则其每一个输人的逻辑努力为2。这句话中的每一个输入应该是☞$C_i$.稍微画一下就可以了
> 3. 关键是这意味着优化尺⼨以达到最⼩延时的最优扇出数应当为(4/2）=2. 这里的原因是, 每一级的h为4的时候, 延时最小. h=fg,而这里的g是2,所以$C_i$的扇出应该为2. 扇出的定义为: 该门的外部负载电容和输⼈电容之间的⽐.先计算一下不变的时候, 输入电容是6, 输出电容是6*?+17, 因此为了保证扇出为2, 因此把进位产生的左列面积扩大三到四, 这样f=18+17/(18)约为2.
> 4. 为什么这个保证了每一级晶体管尺寸的相同, 是巧合还是能够算出来的?尺寸相同,保证的是这一级的输入是6, 下一级的输入也是6. 是8, 也是8.那到底是几呢, 就是18呗, 18就是比6扩大了三倍. 
> 5. <span style="background:#d3f8b6">那逻辑努力还符合吗? 不符合, 逻辑努力从2变成了6, 对应的f也应该变, 所以教材是不是错了??</span>
> 6. <span style="background:#d3f8b6">只改一部分, 最差情况的R确实还可以, 但合理吗?</span>
### (3)传输门加法器
![[support/img/Pasted image 20231229204628.png|600]]
#### A: 电路分析
##### a:第一列
简单的产生 $\overline A$ 和 $\overline C_i$
##### b:第二列
P为要产生的结果, 左右两边往中间来传导.
只看上边的P
1. A=1的时候, 左列传不到中间去, 右边是反相器, 因此有$P=A\overline B$.
2. A=0的时候, 右列传不到中间去, 左边传来B, 因此有$P=B\overline A$.
<span style="background:#d3f8b6">把这两个相加</span>, 因此$P=A\overline B+B\overline A$,结果就是A和B异或.
> 异或（XOR）运算的符号通常用 ⊕ 表示。
> 同或（XNOR）运算的符号通常用 ⊙ 表示。

##### b:第三列
先看反相器之前的$\overline S=\overline P\overline C_i+PC_i$, 因此可以推导得到$S=P\oplus C_i$
下边一样的,可以推出$C_o=\overline{P}A+PC_i$ (==*也就等于$G+PC_{i}$)*==
#### B: 特点
- 共24个管子，输出既有 SUM， Carry，又有它们的反信号。
- <span style="background:#d3f8b6"><font color="#ff0000">SUM 和 Carry 的延迟时间相同。</font></span>
- 无阈值损失。

### (4)动态曼彻斯特进位链
#### A:工作原理
关键在于相比于传输门的加法器好在哪里. 课本上的叙述如下:
> 图 11.7 中的进位传播电路可以通过增加进位产生和进位消除信号来简化，如图 11.8(a)所示。进位传播路径不充电，如果进位传播信号$(A_i\oplus B_i)$为真，则$C_i$被传送至输出$C_i$${\text{。如果传播条件不满}}$足，则输出或者由信号$D_i$下拉或者由$\overline{G}_i$上拉。如图 11.8(b)所示，动态实现甚至可以使电路更加简单。由于动态电路中的晶体管是单方向工作的，所以可以只用 NMOS 传输管来代替传输门。预充电输出使电路不再需要进位取消信号(对于进位链，传播的是进位信号的反信号时的情形)。![[support/img/Pasted image 20240110123652.png]]

> [!question] 疑问
> 1. 首先, 这是传输门的设计, 是对的, 因此有承接上文的关系
> 2. 但没看出来快在哪, 或者说这个进位链和之前的有什么不同
> 3. 没懂上文叙述的`进位传播路径不充电`
> 4. 没懂上文叙述的`由于动态电路中的晶体管是单方向工作的，所以可以只用 NMOS 传输管来代替传输门`

##### a:静态实现
好说, 有p就传过去, 没有就直接上拉下拉
##### b:动态实现
$\phi=0$的时候, 预充电. 节点被冲到$V_{DD}$, P=1的时候, $C_{o}$被放电或者==*不变(动态, 所以没阈值损失,, 所以上边说是单向工作的)*==, G=1的时候也被放电(因为这里是$\overline{C_{o}}$). 
#### B: 动态逻辑实现的Manchester进位链（4 比特）
##### a:结构图
也没啥好说的吧
![[support/img/Pasted image 20240110124525.png|500]]
##### b:动态Manchester进位链延时
最坏情况如下:
![[support/img/Pasted image 20240110124718.png|400]]
因此可以计算延时为: $$t_P=0.69\sum_{i=0}^NC_i(\sum_{j=0}^iR_j)=0.69\frac{N(N+1)}{2}RC$$
因此==*和$N的平方$成正比*==.
在本例子中, 放电路径上的延时具体计算如下: $$\begin{aligned} t_{P} &= 0.69\left[C_{0}R_{0}+C_{1}\left(R_{0}+R_{1}\right)+C_{2}\left(R_{0}+R_{1}+R_{2}\right)\right. \\ & \quad \left. +C_{3}\left(R_{0}+R_{1}+R_{2}+R_{3}\right)+C_{4}\left(R_{0}+R_{1}+R_{2}+R_{4}\right)\right] \end{aligned}$$
##### c: 尺寸设计
关键在于理解K是如何影响了延时, ==*怎么就从平方变成线性了*==, 因为尺寸变了对吧, RC的值不一样了, 不能用刚刚的公式了
![[support/img/Pasted image 20240110125533.png|550]]
##### d:特点
- 采用动态逻辑降低复杂性和加快速度；
- 预充电时所有中间节点被预充至$V_{DD}$ ，求值时有条件放电
- 进位链传输管只用 N 管，节点电容很小，==**为四个扩散电容；**==
- 进位链的分布RC 本质使传播延时与位数N的平方成正比，因 此有==**必要插入缓冲器**==；
- <font color="#ff0000">从输出端到输入端通过进位链管子的放电电流逐步加大，因此 从输出端到输入端逐步加大进位链管子的尺寸可提高速度。</font>
#### C: 曼彻斯特进位链的静态实现
![[support/img/Pasted image 20240110130000.png|200]]
- 进位传播由信号 P 控制传输管实现
- 进位产生由信号 G 控制上拉电路实现
- 进位清除由信号 D（Delete 或Kill）控制下拉电路实现
##### a:特点
- 不需要时钟、预充电，==**可异步工作，一旦给出运算数 a，b 进位链马上工作，由此可提高速度**==；
- ==**采用CMOS , 可降低功耗**==；
- 如进位链较长时，应在 $C_i，C_{i-1}…$ 回路上==**插入缓冲级**==。
### (5)小结
![[support/img/Pasted image 20231229210315.png|600]]
## 3. 逻辑级设计
### (1)进位旁路加法器( Carry-Bypass Adder )
设计思想: 中间信号GDP只和AB有关系, 和C无关, 而要想C从第一级传递到最后一级, 需要保证P一直为1, 但凡不是, 信号就需要从中间的某一级产生. 因此就有了下图![[support/img/Pasted image 20240110135902.png|400]]
这个选择器的意思就是, 最长的路径就是从第一级一直传到最后一级的, 现在直接给他摘出来, 几个P都是1的时候, 直接传到最终的C, ==最慢的变最快的了==, 只要不是P全是1, 那就没得说, 还得挨个算
#### A:多位的情况
肯定不是16为就来一个选择器, 需要四位四位的来
![[support/img/Pasted image 20240110141229.png|400]]
#### B:延时计算
核心思想: 
1. 哪一位的A和B产生了一个G或者D, 那么之前的Carry的延时都不重要了, 所以最坏的情况就是, 只有第一位(或者第一位也不是)可以产生G或者D, 其余的位全都是P, 这样才能最长, 也就是==后边不能出现D和G, 只能第一位出现D和G==
2. 每一位都需要上一位的进位来算, G和D的作用无非是让下一位需要的进位早早地算出来了, 但是就比如P=1111越过去的这四个进位, 照样是需要C传进去来算的, ==只不过是不是关键路径, 所以没画出来==
因此最长的路径如下: 
![[support/img/Pasted image 20240110194350.png|500]]
$$t_{adder}=t_{setup}+Mt_{carry}+(N/M-1)t_{bypass}+(M-1)t_{carry}+t_{sum}$$
> [!question] 组成部分的疑惑
> 1. 为啥会有一个建立时间, 这是啥
> 2. 第一位的建立完成了, 直接产生一个carry就好了, M个bit的时候, 应该只需要M-1啊, 为啥还得是M?
> 3. 注意, 那是$\frac{N}{M}-1$
#### C:路径举例
![[support/img/Pasted image 20240110194810.png|500]]
![[support/img/Pasted image 20240110194821.png|500]]
#### D:trade-off
- 面![[support/img/Pasted image 20240110194951.png#right|trade-off|200]]积: 增加进位旁路一般使面积增加 10% 至20%。
- 进位旁路加法器的总进位传播时间仍与位数 N 成正比，但<font color="#ff0000">比例系 数比逐位进位加法器小</font>。
- N 较小时，旁路的额外开销使 采用旁路进位的收益不大。一般 <font color="#ff0000">N 在 4 ~ 8 以上采用旁路进位</font>。
### (2)4 位线性选择进位（Linear Carry-Select Adder）
#### A:结构&工作原理
核![[support/img/Pasted image 20240110195237.png#right|线性进位选择加法器|150]]心思想就是, 我提前算出来, 这一级(这4个bit)在输入的进位是0或者1的时候<font color="#ff0000">C的结果</font>是多少, 然后, 等到真正地进位来的时候, 直接就当选择信号选过去就完事了.

#### B:关键路径

![[support/img/Pasted image 20240110200009.png|500]]
$$t_{adder}=t_{setup}+Mt_{carry}+\frac NMt_{mux}+t_{sum}$$
很清晰的, M是一组为多少.
- 面积大概多进位路径和一个MUX, 多30%
- 速度的话, 还是正比, 但是÷M了
#### C:改进方案
那意思就是, 我不能浪费时间, 就比如, 我第一个C到的时候, 最好的情况是, 第一个的两种情况刚算完, 我直接就可以选了, 这样不浪费, 但是图中这个显然第一个55可以, 之后的65,75,85都不可以的.
![[support/img/Pasted image 20240110200248.png|500]]
### (3)平方根进位选择加法器
#### A:工作原理
根据上边的原理, ==每一级比前边多一位, 以弥补选择器的延迟==, 因此有了![[support/img/Pasted image 20240110200454.png|500]]
#### B:关键路径
假设N 位的加法器含有 P 个级，且第一级加是 M位，后续级逐级增加一位， 于是：
$$
\begin{aligned}
N &= M+(M+1)+(M+2)+\cdots+(M+P-1)\\
&= MP+\frac{P(P-1)}{2}=\frac{P^{2}}{2}+P\left(M-\frac{1}{2}\right)
\end{aligned}
$$
 若 $M<<N$ , (如$\mathbf{M}=2,\mathbf{N}=64)$ , 则
$$
N=\frac{P^{2}}{2}+P(M-\frac{1}{2})\approx\frac{P^{2}}{2}
$$
 于是$$
P=\sqrt{2N}
$$==*此时延时正比于$\sqrt{2N}$(亚线性关系),而不是$N$(线性关系)*== 当$N$ 很大时，延时几乎变为常数。
![[support/img/Pasted image 20240110201054.png|400]]
### (4)超前进位加法器
#### A:工作原理
核心原理: ==*递归*==
由于$${C_{i+1}=G_i+P_iC_i}$$
这就存在着$$\begin{aligned}
&\mathbf{C}_{o,0} =\boldsymbol{G}_{0}+\boldsymbol{P}_{0}\boldsymbol{C}_{i,0}  \\
&C_{o,1} =G_{1}+P_{1}C_{o,0}=G_{1}+P_{1}G_{0}+P_{1}P_{0}C_{i,0}  \\
&\mathbf{C}_{o,2} =G_{2}+P_{2}C_{o,1}=G_{2}+P_{2}G_{1}+P_{2}P_{1}G_{0}+P_{2}P_{1}P_{0}C_{i,0}  \\
&C_{o,3} =G_{3}+P_{3}C_{o,3}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}+P_{3}P_{2}P_{1}P_{0}C_{i,0} 
\end{aligned}$$因此可以归纳为$$\begin{aligned}
C_{o,k}& =G_{k}+P_{k}C_{o,k-1}=G_{k}+P_{k}(G_{k-1}+P_{k-1}C_{o,k-2})  \\
&=G_{k}+P_{k}(G_{k-1}+P_{k-1}(...+P_{1}(G_{0}+P_{0}C_{i,0}))) \\
&=G_{k}+P_{k}G_{k-1}+P_{k}P_{k-1}G_{k-2}+...+P_{k}P_{k-1}...P_{1}G_{0}+P_{k}P_{k-1}...P_{0}C_{i,0}
\end{aligned}$$
$因此第k级C的输出之中, 只存在着C_{i,0}, 其余的全都是各级P和G$而各级P和G都能直接从各级的AB直接得出来, 因此根本就不需要等待前一级的C的输入就可以了.
#### B:详细考虑
- 从逻辑设计角度
	超前进位加法器的进位递归式的展开可以一直继续下去，如果展 开k 次，就得到==两个层次的AND-OR 结构==，可见，<font color="#ff0000">每一位的进位输 出只与最初的进位输入有关，而与比它低位的其他进位输入无关， 因此加法时间与位数 N 无关。</font>
- 从电路设计角度
	AND 的扇入= k + 1，OR 的扇入= k + 1，于是有 k + 1 个MOS 晶 体管堆叠。因此，当位数N 较大时，电路的大扇入会使速度变慢， 如采用较简单的门来实现，就会要求较多的逻辑层次。而且某些信 号的扇出还有可能进一步地增加，使加法器的延时加大。同时，加 法器的实现面积也会随位数N 的增加而增加。==*因此这一超前进位只 对小的N 值（ N <=4 ）有效。*==
> 对于上述扇入的解释: 仔细观察$C_{o,k}$的最终形式, 是$k+1$个积项相加, 而最后一个积项是$k+1$个相乘, 因此就有了上边说的`AND 的扇入= k + 1，OR 的扇入= k + 1`.
#### C:结构图
![[support/img/Pasted image 20240110234923.png|500]]
为啥前边小, 因为前边不需要很多P传进来, 而后边的和的计算需要前边的P传进来
### (5)对数超前进位加法器
#### A:电路原理
由于$${C_{i+1}=G_i+P_iC_i}$$定义运算$$(A,B)\cdot (C,D)=(A+BC,BD)$$
则有$$(C_{i+1},0)=(G_{i},P_{i})\cdot(C_{i},0)$$
而又由于$$(C_{i+2},0)=(G_{i+1},P_{i+1})\cdot(C_{i+1},0)$$
因此有$$(C_{i+2},0)=(G_{i+1},P_{i+1})\cdot[(G_{i},P_{i})\cdot(C_{i},0)]$$
接下来可以证明结合律, 因此可以拆掉上边的中括号, 证明如下
$$\begin{align*}
C_{i+2} &= G_{i+1} + P_{i+1} C_{i+1} \\
&= G_{i+1} + P_{i+1} (G_{i} + P_{i}  C_{i}) \\
&= G_{i+1} + P_{i+1}  G_{i} + P_{i+1}  P_{i}  C_{i} \\ 
&=(G_{i+1}+P_{i+1}G_{i},P_{i+1}  P_{i} )\cdot(C_{i},0) \\ &=[(G_{i+1},P_{i+1})\cdot(G_{i},P_{i})]\cdot(C_{i},0)
\end{align*}
$$
因此联立以上两个式子, 就可以得到交换律的成立. 
通过递推关系和交换律可以得到: $${(C_{\mathrm{out}},0)}\color{red}{=}(G_{\mathrm{N-1}},P_{\mathrm{N-1}})\color{red}{\bullet}\ldots\color{red}{\bullet(G_1,P_1)}\color{red}{\bullet(G_0,P_0)}\color{red}{\bullet(C_{\mathrm{in}},0)}$$
==*中间可以任意加括号.*==
因此有$$(C_{_{o,7}},0)=(G_{_{7:6}},P_{_{7:6}})\Theta(G_{_{5:4}},P_{_{5:4}})\Theta(G_{_{3:2}},P_{_{3:2}})\Theta(G_{_{1:0}},P_{_{1:0}})\Theta(C_{_{i,0}},0)$$
其中$$(G_{_{a:b}},P_{_{a:b}})=(G_{_{a}},P_{_{a}})\Theta(G_{_{a-1}},P_{_{a-1}})\Theta\cdots\Theta (G_{_{b}},P_{_{b}})$$
因此==*第8位的产生*==可以将![[support/img/Pasted image 20240111102114.png|400]]
转化为![[support/img/Pasted image 20240111102124.png|300]]
在电路结构上实现起来即为
1. 四位:![[support/img/Pasted image 20240111102204.png|400]]
2. 16位
![[support/img/Pasted image 20240111102414.png#right||150]]![[support/img/Pasted image 20240111102239.png|分支节点|400]]
> 对于十六位的理解, 因为刚刚的最高级结构之给了2的m此幂的结构, 在非1248的数上, 产生了很多其余的线.

#### B:节点操作电路实现
节点无非是一个与一个或, 因此就是用动态电路实现如下![[support/img/Pasted image 20240111102642.png|400]]
具体应用的时候就是![[support/img/Pasted image 20240111102701.png|500]]
==**取消求职管预充电的传播效应==**
**==多米诺逻辑练接**==
#### C:延时
对数超前进位加法器电路的特点：
1. 逻辑层数正比于 $\log_2N$, 因此传播延时也正比于 $\log_2N$
 2. ==**一旦得到进位，可在常数时间内求得“和”**==

## 4. 总结
### (1)延时和面积比较
![[support/img/Pasted image 20240111102921.png|400]]
### (2)减法器实现
#👁 
![[support/img/Pasted image 20240111102944.png|400]]
### (3)小结
电路级设计
- 静态互补CMOS全加器
- 镜像加法器
- 曼彻斯特进位链
逻辑级设计
- 进位旁路加法器
- 线性进位选择加法器/平方根进位选择加法器
- 超前进位加法器
典型结构:
1. Ripple（逐位进位） 加法器
	1. 面积小，简单，如速度可以接受，应首先考虑使用
	2. 易改成流水线加法器
2. Carry Look Ahead （CLA）加法器：
	1. 非常快的非流水线加法器（连线不规则）
	2. 功耗相对较大
3. Manchester 加法器：
	1. 规则，较小，较快
	2. 适合于全定制设计的数据通路，字宽16~ 32位
4. Carry-Select Adder：
	1. 较快的n 位加法器
	2. 容易用Ripple Adder 和MUX 组装
	3. 面积较大
5. 传输门加法器：
	1. 进位传输与求和延迟时间接近（如在乘法阵列中）
# 三、乘法器
==乘法器这一部分根据课本上的思路来==
🏀**定义乘法运算**
考虑两个没有符号的⼆进制数X和Y，分别为M位宽和N位宽。为了说明乘法运算，下标i表示第i位，可以⽤⼆进制形式来表示X和Y：$$X=\sum_{i=0}^{M-1}X_{i}2^{i}\quad Y=\sum_{j=0}^{N-1}Y_{j}2^{j}$$
> [!question] 数字存在绝对大小吗？
> 存在的吧，上边这个式子左边就表示的X和Y的绝对大小

乘法运算的==**定义（有啥用）**==如下：$$\begin{aligned}Z&=X\times Y=\sum_{k=0}^{M+N-1}Z_k2^k\\&=\bigg(\sum_{i=0}^{M-1}X_i2^i\bigg)\bigg(\sum_{j=0}^{N-1}Y_j2^j\bigg)=\sum_{i=0}^{M-1}\bigg(\sum_{j=0}^{N-1}X_iY_j2^{i+j}\bigg)\end{aligned}$$
🏀**乘法运算最简单的⽅法**
最简单的方法是<font color="#ff0000">采⽤⼀个两输⼈的加法器</font>, 对于M和N位宽的两个输入, 乘法器采用一个N位宽的加法器, ==**则需要M个周期**==. 这段时间内做的事情是把M个部分积相加.
> [!question] M个周期
> 使用N位宽的两输入加法器, 那么, 一个周期能算N位, 由于是M和N相乘, 因此有M个部分积, M个部分积相加, 需要进行M-1次运算, 这样, ==取出最终的结果需要M个周期==

注意,这里不是简单的相加, 而是移位错开相加(移位是手工移位还是怎么着), 确实虽然是错位相加, 也只需要N位,而不是N+1位, ==**但是结果怎么去组织得到呢?**==
🏀**部分积的产生⽅法**
就是M中的某一位和N做与运算
🏀**实现乘法的一个更快的办法是**采用类似于手工计算乘法的方法。<font color="#ff0000">所有的部分积同时产生</font>并组成一个阵列。运用多操作数相加来计算最终的积。这一方法如图11.28所示。这一组操作可以<font color="#ff0000">直接映射到硬件</font>。所形成的结构称为==*阵列乘法器（array multiplier）*==， 它结合了下面三个功能：
1. 产生部分积
2. 累加部分积
3. 最终相加
## 1.部分积的产⽣
部分积是被乘数$X$ 和一个乘数位$Y_i$进行逻辑 AND 操作的结果( 见图 11.29)。部分积阵列中的每一行或者==是被乘数的一个副本或者全部是0==。仔<u>细地优化部分积的产生能够显著减少延时和面积。</u>注意，大多数情况下部分积阵列中有许多行全部是0，它们对运算结果没有任何影响，因而在进行相加时是一种浪费。当一个乘数全部由 1 构成时，所有部分积都存在，而在乘数全部为零时则一个部分积也没有。==**这一观察可以使我们把所产生的部分积的数量减少一半。**==
### (1):减少部分积的数量
例如假设有一个8 位乘数 01111110, 它将产生 6 行非零的部分积。
如果把该数字$(2^6+2^5+$ $2^4+2^3+2^2+2^1)$记成另一种形式$1000\_00\overline10$ ，则可以大大减少非零行的数目(这里$\bar{1}$ 是$-1$ 的缩写符号)表示的是同一个数字。
> 由于是负数, 那么这个数就是$2^7-2^1=126$, 和上边的$(2^6+2^5+$ $2^4+2^3+2^2+2^1)=126$算出来是一个值

采用这一形式，我们只需相加两个部分积，==*但最终的加法器必须也能执行减法*==。这种形式的变换称为波兹(Booth)编码$^{[\text{RoothS1}]}$,它使部分积的数目至少可以减少到原来的一半。
它保证了在==每两个连续位中最多只有一个是$1 或 -1$。(这句话的意思是, 编完码之后的二进制乘数). ==部分积数目的减少意味着相加次数的减少，从而加快了运算速度并减少了面积。
#### A:波兹编码
那到底如何从 0111110变成$1000\_00\overline10$ 的呢?采用了波兹编码技术.
具体的推导过程如下:
因为是缩减一半, 那么我就每两位产生一个部分积.
**00还是0, 01还是1, 10就是2倍, 11就是3倍**
产生的部分积, 错开两位相加.
<font color="#ff0000">3倍又是4-1</font>
因此11就是, 可以变为$10\overline{1}$.
根据原来的数字 0111110

|  | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|  |  |  |  |  |  |  | 1 | 0 |
|  |  |  |  | 1 | 0 | -1 |  |  |
|  |  | 1 | 0 | -1 |  |  |  |  |
|  | 0 | 1 |  |  |  |  |  |  |
| 初始结果 | 1 | 0 | 0 | 0 | 0 | -1 | 1 | 0 |
| 继续化简 | 1 | 0 | 0 | 0 | 0 | 0 | -1 | 0 |
这就得到了最终的结果.
> [!question] 相邻两位最多一个1或者-1
> 11-->10-1
> -1-1-->不出现
> 1-1-->01
> -11-->0-1
#### B:改进的波兹编码
上边还需要从初始结果继续化简, 此处改进.
**乘数按三位⼀组进⾏划分，相互重叠⼀位。**
按照以下表格进行编码![[support/img/Pasted image 20240113140410.png|200]]
则对于0111_1110有以下的编码:考虑前面提及的8位二进制数 0111110。从 msb 至 lsb, 可以把它分为三位一组首尾重叠的四组：01(1),11(1),11(1),10(0)。根据表11.2编码得到：10(2x),00(0x),00(0x),-10(-2x), 组合为$1000\_00\overline10$ 
![[support/img/Pasted image 20240113141249.png|500]]
这就得到了最终的结果.
##### a:数据扩充
1. 总比特数为偶数
	1. 高位扩充 2 位（有符号数扩充符号位，无符号数扩充 0）
	2. 低位扩充 1 位（扩充 0
2. 总比特数为奇数
	1. 高位扩充 1 位（有符号数扩充符号位，无符号数扩充 0）
	2. 低位扩充 1 位（扩充 0）'=
**为什么要进行数据扩充?** 见以下例子
![[support/img/Pasted image 20240113141330.png|300]]
![[support/img/Pasted image 20240113141521.png|300]]
第一个无符号数的例子,如果不扩充, 就得到了一个负数.
==*这里的部分积从4个变成了5个*==, 但是八位数还有很多情况, 这种情况下确实是产生了更多的部分积
##### b:例子
![[support/img/Pasted image 20240113141636.png|500]]
##### c:对于改进波兹编码的证明
证明编码公式, 以及*为什么可以减少部分积的数量*![[support/img/Pasted image 20240113141842.png|400]]![[support/img/Pasted image 20240113141909.png|400]]
##### d:优缺点
🏀优点:
- 部分积数目==**最多为位宽的一半+1**==，可用于无符号数 及2’s 补码。
- 代价是：除0、X外，还有+2X、-2X、==**+X**==和-X， 因此需要==*译码(结构上直接映射, 还是需要识别3位之后, 看看结果是左移or求反的组合*==，对负项还要“ 求反加1 ”。

##### e:结构上的变化
🏀结构上???
用这一堆组合逻辑电路, 省掉了==一些可能的时钟周期(**那我怎么知道到底产生了多少个时钟周期呢??难道要编码完用硬件查不是0的个数吗?**)==.
## 2.部分积的累加
部分积产生之后，必须将它们相加。这种累加基本上是一个多操作数的加法。一个直接累加部分积的方法是用许多<font color="#ff0000">加法器形成阵列，因而得名阵列乘法器</font>（aray multiplier）。一个更为先进的方法是以树结构的形式完成加法。
### (1)基于逐位进位加法器（RCA）的 阵列乘法器
图![[support/img/Pasted image 20240113150121.png#right|部分积相加|300]]11.30显示了一个阵列乘法器的组成。它的硬件结构与图11.28中的手工乘法之间在拓扑结构上一一对应。产生N个部分积需要有$N×M$个两位的AND门（如图11.29的方式）。乘法器的大部分面积都用于把N 个部分积相加，<font color="#ff0000">这需要有N-1个M位的加法器</font>。使部分积正确对位的移位通过简单布线来完成，==*而不需要任何逻辑电路。*==整个结构可以很容易地压缩成一个矩形，使它的版图非常紧凑。



![[support/img/Pasted image 20240113150113.png]]
> m×n的乘法器需要
> 1. n个半加器
> 2. mn-m-n个全加器
> 3. mn个与门
#### A:传播延时
为了优化性能，⾸先需要识别关键的时序路径。这⼀任务并不 简单。事实上，可以看到这⾥有许多⻓度⼉乎⼀致的路径。![[support/img/Pasted image 20240113150404.png|500]]
$$t_{mult}=[(M-1)+(N-2)]t_{carry}+(N-1)t_{sum}+t_{and}$$
!!!!!!!!!!==公式中这个$N-2$真的很神奇==, N-1是列数, 列数之间有$N-1-1$个空隙, 因此是$N-2$
#### B:全加器结构
乘法器存在许多延时几乎相同的关键路径，因此重点放在加法器的优化上，即，使加法器的Sum和Carry的传输时间相同
![[support/img/Pasted image 20240113152218.png]]
<font color="#ff0000">因此通常使用传输门构成的全加器</font>
> [!question] 为什么关键路径多会更不好?
> 只优化了一个路径, 其余的路径没变啊, 要是路径少, 我只需要考虑优化某一条路径上的

![[support/img/Pasted image 20240113152306.png|400]]
### (2)进位保留乘法器 ( Carry-Save Multiplier)
🏀**思想在于:** 
由于阵列乘法器中有许多⼏乎相同的关键路径，通过调整晶体管的尺⼨来提⾼这⼀结构的 性能效果⾮常有限。但若注意到，<font color="#ff0000">当使进位输出位如图 11.32 所⽰向下沿对⾓线通过⽽不只是向左通过时乘法的结果并不改变</font>，就可以得到⼀个更有效的实现。
> [!question] 三个问题
> **为什么结果不改变?**
> - 结果不变: 进位从传到左边的, 变成传到左下方的, 只要是传到左边那一列就行, 因为权重是一样的.
> 
> **为什么矢量合并加法器可以用快速加法器?**
> - 矢量合并:最后一行也要往左下方传播, 因此, 最下边需要多一行.==**那为啥在之前RCA的最后一列时候不用快速加法器呢**==? 在之前的RCA之中, 到达最后一行的四个加法器的输入数据的时间是不一样的, 也就是说, 第一个到的最快, 因为竖着传的都是M-1个sum, 但是横着到底是几个carry, 决定了右边最快, 左边最慢. 要是在此时使用超前进位, 你进位到左边再快, 没有什么用, 因为我最左边的输入数据就需要很久才到.
> - 但是在进位保留乘法器中, 我所有到倒数第二行, 也就是矢量合并加法器的数据的时间别管在哪一列, 时间都是一样的, 因此, 我可以最后用一个快速的加法器, 而这个加法器的关键路径, 就是最后一行从右到左的了, 因此只有到达最后一行的HA的输入, 往前走的, 才算做关键路径, 因此关键路径数量减少
>
> **为什么关键路径变少?**
> - 假设Carry和Sum的延时是一样的, 如上述所述

![[support/img/Pasted image 20240113152350.png|500]]
#### A:延时
$$t_{mult}=(N-1)t_{carry}+t_{and}+t_{merge}$$
这个$t_{and}$怎么理解?![[support/img/Pasted image 20240113162552.png|400]]
#### B:拓扑结构

![[support/img/Pasted image 20240113162702.png|400]]
### (3)树形乘法器
#### A:原理
部分和加法器也可以安排成树形，这可以同时减少关键路径和所需的加法器单元数目。考虑四个部分积的一个简单例子，每一个部分积都是四位宽，如图 11.34(a)所示。可以看到在阵列中只有第三列必须加四位，所以可以减少这一操作所需的全加器数目。其他所有的列则稍微简单些。这显示在图 11.34(b)中，图中原来的部分积矩阵重新安排成树形以直观地说明它的不同深度。![[support/img/Pasted image 20240113162928.png|500]]
🏀**我来解释这个东西**
以前要实现这个4×4的话, 按照之前的阵列分布, 那我必须要用3x4个加法器(RCA), 
但实际上我不需要这么多, 为啥呢.
全加器就是把三个输入,(半加器就是把两个输入) 变成了
1. 这一级(这一列)的一个数-->和
2. 前一列的一个数-->进位
因此, 一列上最多的数据个数就是前一列的进位加上本列的原始数据.因此, 就有了上边那个图, 我先算最深的一层, 全加器和半加器只是输入的个数不一样, <font color="#ff0000">但是, 都是本列余下一个, 前一列加一个</font>. 因此, 尖尖角使用一个半加器, 能使得中间列4行变三行, 但前边的一列就从3行变4行, 因此前边也来一个, 使得第四列从4行变3行, 第五列从2行变3行, 现在全都是3行了, 之后想办法都变成两行.
两行之后就结束了, 直接就有结果了
**🌰8×8的华莱士🌲**
![[support/img/Pasted image 20240113164912.png|600]]
肯定不行, 因为8,起码要给前边来三位, 自己留下三位, 而7也是, 所以最小也是3+3=6
![[support/img/Pasted image 20240113164925.png|600]]
==一个很关键的是, 很多方法到6行, 但怎么使得每一步用的加法器都最少就是指的考虑得了==
#### B:电路结构
根据4×4的图, ![[support/img/Pasted image 20240113165142.png|400]]一定要可以看出,那个点点变成tree之后, 其实就从部分积原来所在行上移了, ==因此问题就是, 要从🌲中对应回原来的平行四边形结构==
一个点点代表的是一个$x_{i}y_{j}$, 比如尖尖上的就是$x_{0}y_{3}$, 结果的和与谁进行加法, 就把SUm信号连到谁那里, 进位也一样, 这样便可以对应出结构![[support/img/Pasted image 20240113165541.png|500]]
#### C特点
- 优点:
	- 在通常的阵列乘法器中，乘法延迟时间正比于n 。
	- 在基4 改进波茨编码乘法器中，乘法延迟时间正比于n/2 
	- 采用压缩比为3：2的Wallace Tree 乘法器的乘法延迟时间正比于$\log_{3/2}(\frac n2)$ 。最后还需将<font color="#ff0000">最终的两个数相加</font>。
	> ==**对于最长路径的证明**==: ![[support/img/Pasted image 20240113165724.png]]
- 缺点
	- Wallace Tree 乘法器非常不规则，给版图设计带来困难
> [!question] 波兹编码和Tree可以混着用吧?
> 一个是部分积产生的结构, 一个是累加的结构
> 
## 3.最终相加
完成乘法的最后一步是在最终加法器中合并结果。这一“向量合并”操作的性能至关重要。 加法器类型的选择取决于累加阵列的结构。如果加法器的所有输人位同时到达，则最好选择一个超前进位加法器，因为它产生最小可能的延时。==**当一个流水线级正好放在最终相加的前面时就是这种情况。**==流水线是高性能乘法器经常采用的技术。在非流水线乘法器中，由于乘法器树逻辑深度不同，最终加法器输入到达的时间非常不一致。这时，采用其他加法器结构，如进位选择加法器，常常能达到与超前进位加法器类似的性能指标，而硬件的成本却低得多（Okondajol）。
## 4.小结
![[support/img/Pasted image 20240113170143.png|500]]

# 四、移位器
🏀**移位种类**
- 逻辑移位：空位补0
- 算术移位：右移要进行符号扩展
- 循环移位
> *漏斗型移位器（Funnel Shifter）能完成以上所有这些移位功能*

🌰**例子如下**![[support/img/Pasted image 20240113172855.png|400]]
🏀**1比特移位器举例**
![[support/img/Pasted image 20240113173008.png|300]]
很好理解, 有三条线连到输出, 要是选本级就是nop, 要是==选左边的就是右移==, 反之
## 1. 桶型移位器
### (1)工作原理
图 11.37是⼀个桶形移位器的结构。
- 它由⼀个晶体管阵列构成，<font color="#ff0000">其⾏数等于数据的字⻓，⽽ 列数则等于最⼤的移位宽度</font>。在本例中，⼆者均为4。
- 控制线沿对⻆线布置通过该阵列。
- 这种移 位器的**主要优点**是信号最多只需通过⼀个传输⻔。换⾔之，传播延时在理论上是常数，与移位的 位数或移位器的规模⽆关。
- 但在实际中并不是这样，==**因为缓冲器输⼈端的电容随最⼤移位宽度 线性地增加。**==
![[support/img/Pasted image 20240113173341.png|500]]
> 对于上图的解释, 每一个NMOS的漏源连接输入和输出, 在一行上, 所有的输出都连到B的同一位, 但是输入是看到底哪个NMOS打开了.打开了, 就去找这个竖着的线到底是A的哪一位传过来的就行了.注意,==符号位是自动复制的, 也就是图中左上这一部分的内容==

### (2)版图
*版图宽度由金属线的宽度和金属线间的
距离来决定.* 
> *这⼀电路的⼀个重要特点是它的版图尺⼨并不是像其他运算电路那样由有源晶体管来决定， ⽽是由通过该单元的布线数⽇来决定。更具体地说，移位单元的尺⼨由⾦属线的节距来确定！*

![[support/img/Pasted image 20240113174821.png|500]]
### (3)译码模块
选择移位器时另一个重要的考虑是移位值必须表示为何种形式。从图 11.37 的电路图中可以看到，桶形移位器的每个移位都需要一条控制线。例如，一个四位的移位器需要四条控制信号。为了移三位，信号$Sh_{3}{:}Sh_{0}$的值应为 <font color="#ff0000">1000。只有一个信号是高电平。在处理器中，通常把需要移位的值以更为简洁的二进制形式编码。例如，这里的编码控制字只需要两个控制信号，对于移动三位控制信号表示为 11</font>。为了把后一个表示方法转化为前者( 即只有一位为高电平),需要增加一个译码器模块(译码器将在第 12 章中详细介绍)。
## 2. 对数移位器
桶形移位器把整个移位器实现为传输管的单个阵列，⽽对数移位器则采⽤分级的⽅法。总 的移位值被分解成⼏个2的指数值。⼀个具有最⼤移位宽度 ⼭ 的移位器包括 10g21 级，它的第i 级或者把数据移动2-位或者原样传送数据。图11.38 是⼀个最⼤移位值为7 位的移位器的例⼦。 <font color="#ff0000">例如，要移动5位，第⼀级设置在移位模式，第⼆级为通过模式，⽽最后⼀级又是移位模式。</font>注 意，这个移位器的控制字已经编码，所以不需要单独的译码器。![[support/img/Pasted image 20240113175500.png|500]]
> 关键在于那些竖线, 第一个都是连到下一个, 第二列是连到后2个, 最后一个是连到后4个, 所以1,2,4可以组成任何1~7之间的值

对数移位器的速度以对数方式取决于移位宽度，因为一个$M$位的移位器需要 $\log_2M$ 级。同时，对于较大的移位值，==*传输管的串联连接会减慢移位器的速度。因此，如在第6 章中所讨论的， 有必要仔细插人中间缓冲器。*==
![[support/img/Pasted image 20240113175713.png|500]]
*版图宽度取决于金属宽度和间距*

🏀**移位器特点总结**
- 对数移位器的速度是以对数方式取决于移位宽度的。
- 由于大的移位值会减慢串联传输管的移位速度，因此 必要时应引入中间缓冲器。
- 对数移位器的控制字已被编码，因此不需要单独的译 码器。
- 版图宽度受限于金属线的宽度和间距。
- 从面积和速度考虑，对于较小的移位值，桶型移位器 比较合适；而对于较大的移位值，对数移位器比较有效，*对数移位器容易参数化*，便于自动生成。
*这 ⼀节中最重要的概念是利⽤运算器的规则性有利于密集和⾼速的电路实现。*
# 五、总结
![[support/img/Pasted image 20240113180128.png|600]]
