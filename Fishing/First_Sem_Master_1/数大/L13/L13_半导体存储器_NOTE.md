[[Fishing/First_Sem_Master_1/数大/数大|数大]]
# 一、分类（Classification）
**分类方法：功能、存取方式等**
-  只读存储器（Read-Only，ROM），如Mask ROM
- 可读写存储器（Read-Write，RWM），如SRAM，DRAM
- 非易失性可读写存储器（Nonvolatile Read-Write，NVRWM），如 EPROM，EEPROM，FLASH
**分类方法：按照存储器相对于驱动芯片的位置分类**
- 芯片外存储器（容量相对大），受限于：
	- 有限的 I/O 引线数目
	- 驱动该存储器部件的驱动能力/速度
	- 片外存储器在系统中形成大的 off-chip 输出 电容节点
- 芯片内存储器（容量相对小），可以设计得：
	- 访问速度比较快
	- 可优化（设计）访问存储器的路径
# 二、结构（Architecture）
## 1. 实现结构
### (1)直接实现
![[support/img/Pasted image 20240114102722.png|300]]
### (2)译码器实现
![[support/img/Pasted image 20240114102739.png|350]]
### (3)阵列结构的存储器组织
#👁 
![[support/img/Pasted image 20240114102806.png|400]]
### (4)层次化存储器结构
![[support/img/Pasted image 20240114102825.png|400]]
🌰**4 M比特SRAM举例**
![[support/img/Pasted image 20240114103030.png|400]]
> [!question] **7×7的那个问题**
> 
## 2.时序定义
#👁 
![[support/img/Pasted image 20240114103210.png|400]]
- 读周期（Read cycle）：两次连续的读操作的时间间隔 
- 写周期（Write cycle） ：两次连续的写操作的时间间隔 
- 读出时间（Read access）：读请求到输出数据有效的时间 
- 写入时间（Write access）：写请求到数据写入到存储器的时间
### (1)异步存储器读 操作时序
![[support/img/Pasted image 20240114103341.png|500]]
### (2)同步存储器读 操作时序
![[support/img/Pasted image 20240114103359.png|500]]
# 三、内核（Core）一—存储单元和阵列
## 1. ROM
分为Diode ROM和MOS ROM, 其中MOS ROM又分为上拉,下拉等等很多情况
🏀**Diode ROM**
特![[support/img/Pasted image 20240114103723.png#right|Diode ROM|200]]点:
1. 字线位线不隔离
2. 字线驱动器提供输出驱动
工作原理:WL=1的时候, 就代表选中了字线, 有二极管, 我就能把WL=1的1信号传给输出, 这样我就能读出一个1, 但确实没有隔离, 字线是驱动器, 没有二极管我就读出一个0, 因为1传不过来



🏀**MOS ROM**
![[support/img/Pasted image 20240114104007.png|300]]
特点:
1. MOS管提供输出驱动
2. ==增加面积（电源接触孔）==
工作原理:
WL给栅极, 要是我给了1, 说明选中了, 有没有NMOS, 有的话是上拉还是下拉,都是需要考虑的
### (1)MOS OR ROM
![[support/img/Pasted image 20240114110020.png]]
==为啥叫OR ROM: 接同一位线的NMOS是 “OR” 的关系==. 这里的意思是, 从某一位输出的值来看, 也就是一条竖的线上, 只要我有一个MOS导通, 我就能够给BL拉高.
- 1）<font color="#ff0000">WL = 1表示选中（同 一时刻，只有一个WL = 1， 其余的 WL 0）</font>
- 2）<font color="#ff0000">有管子的地方表示 1</font>
### (2)MOS NOR ROM
![[support/img/Pasted image 20240114110010.png]]
#### A:版图
#👁 
看看上下这两个的区别
- 上边的孔都是有的, 但是Active不是都有, *因此可以表示MOS不是都有*
- 下边的Active都有, 但是孔不一定都有,因此可以表示MOS不是都有
此外, ==Contact面积大, OR类型的面积更大,但是功耗小==
![[support/img/Pasted image 20240114110113.png|500]]
![[support/img/Pasted image 20240114110154.png|500]]
### (3)MOS NAND ROM
#### A:工作原理
- 由于只有一个下拉的地方, NAND而不是NOR, 这也减少了面积, 因为, 不需要那么多交错的电源线了, 但是增加了功耗, 因为没事就得导通着, 只能选一个关死, 这也决定了为啥WL应该只有一个为0
- 由于是下拉, 所以, NAND而不是AND, 也就是全为1(MOS导通),才能下拉
![[support/img/Pasted image 20240114110429.png|500]]
#### B:版图
![[support/img/Pasted image 20240114110723.png|500]]
![[support/img/Pasted image 20240114110737.png|500]]
> [!question] 耗尽管, 注入层, 版图怎么看?
> #👁 
> 
### (4)静态特性
**NOR与NAND ROM电压摆幅比较**
![[support/img/Pasted image 20240114111006.png|500]]
#👁 *公式咋来的*; *串联又怎样*
### (5)动态特性
#### A:MOS NOR ROM等效瞬态模型
#👁 
- *为什么电容形式不一样*
- *为什么是分布rc*
- *为什么可以等效成rc*
- *为什么连线电阻一个是metal一个是poly*
![[support/img/Pasted image 20240114111228.png|500]]
#### B:MOS NAND ROM的等效瞬态模型
#👁 
*WL和poly连线电阻, 以及采取措施*
![[support/img/Pasted image 20240114111408.png|500]]
#### C:如何减小字线延时
#👁 
- 用硅化物代替多晶硅作为字线
- 字线两端驱动
- 用金属连线旁路
*核心是减小电阻吗?*
![[support/img/Pasted image 20240114111534.png|500]]
#### D:预充电MOS NOR ROM
**NOR 和NAND ROM 结构上的缺点：**
- 有比逻辑：$V_{OL}$取决于上拉器件和下拉器件的比(==确实, 只要是N结构, 都有这个问题, 而且静态功耗和有笔逻辑是一个联动的==)
- 静态功耗：输出低电平时有静态功耗
因此提出了: <font color="#ff0000">预充的 4×4 NOR ROM 阵列</font>
![[support/img/Pasted image 20240114111823.png|500]]
**工作原理**
- WL＝1表示选中
- 有管子表示 0
**特点**
- 消除了静态功耗
- 解决了有比问题
- 复杂性不变
- *可独立控制上拉和下拉的速 度： PMOS 预充器件可以 设计得比较大，但太大会使 得时钟驱动变得困难*(大了, 电阻小, 冲得快, 但是电容变大, 时钟负载大)
- <span style="background:#d3f8b6">不需要动态吗?</span>
> [!question] 该结构更适合 NOR ROM 还是 NAND ROM？
> 
## 2. NVRWM
NVRW 存储器的结构实际上与ROW 的结构⼀样。它的存储内核是由⼀个放在字线/位线⽹ 格上的晶体管阵列构成的。存储器通过有选择地使其中某些器件有效或⽆效来进⾏编程。<font color="#ff0000">(也就是, 晶体管都有, 只不过能使他们变成废掉的, 就是通过修改阈值)</font>在 ROM 中，这是通过掩模层的变化来完成的。⽽在 NVRW 存储器中则⽤结构经过修改的晶体管来 代替，这⼀晶体管的國值电 压可以通过电学⽅式来改变。改变的⽹值甚⾄在关断电源电压后仍 能永久(⾄少是在相当长的寿命期内)保持不变。若要对存储器重新编程，必须先擦除原有的编 程值，然后才能开始新⼀轮的编程。<font color="#ff0000">擦除⽅式的不同是各类可重新编程的⾮易失性存储器之间 的主要差别。存储器的编程⼀般⽐它的读操作慢⼀个数量级。</font>

这⼀节先从浮栅晶体管开始描述，它是⼤多数可重新编程存储器的核⼼器件。**本节的其余部分**⽤于说明这⼀器件的许多不同种类，主要是它们的擦除过程不同。
![[support/img/Pasted image 20240114114824.png|500]]
### (1)浮栅晶体管
🏀**浮栅晶体管 (FAMOS)**
![[support/img/Pasted image 20240114112617.png|400]]
#### A:物理结构
- 浮栅晶体管是在NMOS的基础上在控制栅极下的绝缘层之间加入了一层浮栅层，用于储存电子。 其中与沟道接近的绝缘层二氧化硅厚度比较薄，电子在比价大的电场作用下，会隧穿进入浮栅层。
- 浮栅可以捕捉电子并储存，并且由于没有对外的回路，即使掉电之后，电子也不会流失。而浮栅结构中存储的电子的量，可以改变场效应管的导通电压，即Vth。不同的Vth可以代表不同的状态，实现了信息的存储。![[support/img/Pasted image 20240114113027.png|300]]
#### B:状态区分
如何区分0和1呢? 当我编程注入电子之后, 我的阈值提高了, 所以原本我应该导通的变为不导通了, 从1变为0了, 所以写入的过程就是1-->0的过程, 擦除的过程就是0-->1的过程. 详细叙述如下:
- 在写入电子时，​在控制栅极施加相对于衬底高压时，离子井的电子被吸引并隧穿进入浮栅层被存储在其中，如果撤销电压之后，因为浮栅层被绝缘层包裹，浮栅层电子还是存储在这个部位，此状态计为逻辑0。
- 在擦除电子时，需要在衬底加一个相对于栅极的高压，浮栅层存储的电子就会在电场作用下隧穿回到下面的P型半导体里。 此状态逻辑为1. 
![[support/img/Pasted image 20240114114316.png|400]]
🌰==NOR, 编之后, 表示晶体管没了, 也就是我拉不下去了, 因此编就是1==![[support/img/Pasted image 20240114114401.png|500]]
#### C:非易失性存储器的类型不同主要取决于它们的擦除机理
### (2)可擦除可编程只读存储器（EPROM）
- 方式: EPROM 是通过封装上的⼀个透明窗⼝把紫外光(UV)照射到单元上来进⾏擦除的。
- 原理: <font color="#ff0000">UV 辐射通过在氧化物材料中直接产⽣电⼦-空⽳对⽽使这⼀材料稍稍导通。</font>
- 速度: 这⼀擦除过程**很慢**，根据 UV 光源的强度可能需要⼏秒到⼏分钟的时间。编程需要 5~10 us/宇。
- 耐久性: 每编程周期的擦除次数⼀般最多为 1000 次，这主要是由于采⽤了 UV 擦除 过程。
- 可靠性: 也是⼀个问题。器件國值可能随重复编程周期的次数⽽变化，*因此⼤多数 EPROM 存储器还包含有⼀个⽚上电路来控制國值在编程过程中处于所要求的范围之内*。
- 功耗: 最后，注⼈(电荷）过程总需要⼀个很⼤的沟道电流，例如，在控制栅电压为 12.5 V时这个电流可⾼⾄0.5mA。 这造成了编程过程功耗很⼤。
> 另⼀⽅⾯，EPROM 单元结构极简单，密度极⾼，因此有可能以较低成本来⽣产⼤容量存储 器。所以 EPROM 在不需要经常重新编程的应⽤中很受欢迎。但由于价格和可靠性问题，EPROM 已经不再那么受到青睐，⽽被闪存所替代。

缺点: EPROM ⽅法的主要缺点是擦除过程必须在“系统外”进⾏。这意味着存储器必领从*印刷电路板上取⾛并放在⼀个EPROM 的编程器上进⾏编程。*
### (3)电擦除可编程只读存储器(EEPROM 或 $E^2PROM$)
EEPROM 采⽤另⼀种向浮栅注⼈或移去电荷的机制，称为==隧穿效应==(tunneling），从⽽避免了 EPROM 这⼀费⼒⽽⼜令⼈烦恼的过程。

**结构上的变化:** TOX (foating-gate tunneling oxide) 晶体管的浮栅器.
它与FAMOS 器件类似，但隔离浮栅与<font color="#ff0000">沟道和漏端的那⼀⼩部分绝缘介质的厚度减少到⼤约10 nm 或更少</font>。当把⼀个约 10V的电压（相当于约10° V/m 的电场强度）加到这⼀很薄的绝缘层时，电⼦通过 Fowler-Nordheim隧穿机理*穿⼈或穿出浮栅*.
![[support/img/Pasted image 20240114120422.png|400]]

**好处**: 可逆性
这⼀编程⽅法的主要优点在于它的可逆性，即只要把在写过程中所加的电压反过来即可实现擦除。向浮栅注⼈电 将使國值升⾼，⽽相反的操作则降低 Vt.

**坏处**: 会形成耗尽器件

但这⼀双向⼯作带来了國值 控制的问题：==从浮栅上移⾛过多的电 荷会形成耗尽器件(移走之后, 称为正常的NMOS了, 但是这时候G=0的时候, 由于耗尽, 所以关不断了, 由于是Or, 我没选通你这个的时候, 你还导通, 导致我拉低, 那肯定错了这个bit)==，不能⽤标准的字线信号將其关断。注 意，由此形成的國值电压取决于浮栅上的初始电荷以及所加的编程电压。它也与氧化层的厚度 有很⼤关系，⽽后者在整个芯⽚上存在不能忽略的偏差。为了弥补这⼀问题，<u>在BEPROM 单元 上又增加了⼀个额外的晶体管与浮栅晶体管串联。这⼀晶体管在读操作期间作为读取器件，⽽ FLOTOX 管则执⾏存储功能(见图 12.22）。这不同于 EPROM 单元，在EPROM 中FAMOS 管既作为编程器件又作为读取器件。</u>![[support/img/Pasted image 20240114120409.png|400]]
>一由于EEPROM 单元有两个晶体管，所以比相应的 EPROM 要大。而 FLOTOX 器件由于其隧穿氧化层需要额外的==面积==，因而本身就比 FAMOS 管大，所以这一面积上的付出就更大了。此外， 制造非常薄的氧化层是一个难度很大、成本很高的==工艺==过程，因此 EEPROM 部件成本高于EPROM,但却只能==集成较少的位数==。二者相比，EEPROM 的长处是适应性较好，它们也往往==更耐久==，因为它们能支持多至10$^{s}$次擦除/写周期$^{\textcircled{\mathrm{o}}}$。但反复编程会使一些电荷永久地被捕获在 SiO$_{2}$ 中，从而使*阈值电压发生漂移*。这最终会导致功能出错或器件不能重新编程。
>![[support/img/Pasted image 20240114132349.png|500]]
### (4)快闪电擦除可编程只读存储器( Flash)
结合EPROM高密度和EEPROM灵活的特点 
- 编程：雪崩热电子注入
- 擦除：F-N隧道效应
Plash EEPROM 的概念 在 1984 年提出，并很快发展成为应⽤最普遍的⾮易失性存储器结构。它结合了 EPROM 的⾼密度和 BEPROM 结构的变通性的优点，其成本和功能介⼿它们⼆者之间。
在技术上，Flash EEPROM 是 EPROM 和 EEPROM ⽅法的组合。⼤多数 Flash EEPROM 器件采⽤**雪崩热电⼦注⼈的⽅法来编程器件**。**擦除则和 EEPROM 单元⼀样，采⽤ Fowler-Nordheim 隧穿来完成**。
![[support/img/Pasted image 20240114132444.png|400]]
两者主要的差别是 *Flash EEPROM 的擦除是对整个芯⽚或存储器的⼦部分成批进⾏ 的。虽然这代表了在灵活性⽅⾯的减弱，但它的优点是可以省去 BEPROM 单元中额外的存取晶 体管*。(==之前是一个个的擦除, 这样的话, 肯定不可能一个个的检测是不是搞成了耗尽, ⼀次擦除整个存储器内核使得有可能在擦除过程中仔细监测器件的特性，以保证未编程 晶体管的⾏为仍然像⼀个增强器件。存储器芯⽚上的监控硬件在擦除过程中定时检查國值电压 值并动态调整擦除时间。这⼀⽅法只适⽤于⼀次擦除许多存储单元的时候，这也就是 Flash概念 的来源。==)
由于Flash 单元结构⽐较简单，从⽽显著减⼩了单元尺⼨，提⾼了集成密度。
#### A:ETOx Flash
它与FAMOS门类似，但采⽤了⼀个<font color="#ff0000">⾮常薄的隧道概氧化层</font>(10 nm）。==⽤栅氧的不同区城来 进⾏编程和擦除。==
- 在栅和漏端加上⾼电压(12 V)并使源接地时进⾏编程
- 擦除则发⽣在栅接地⽽源处于 12 V时。
![[support/img/Pasted image 20240114132913.png|400]]
#### B:编程过程
**编程过程从擦除操作(a)开始**: <font color="#ff0000">在栅上加上0V电压，源端加上⼀个⾼电压(12 V)。</font>
•擦除前先将所有单元都编程以保证起始阈值大致相同 
•擦除中持续监测（读出）直至所有单元的阈值低于要求值 
•一般擦除时间在100ms到1s之间
浮栅上的电⼦将通过隧穿注射到源端。于是所有的单元被同时擦除。
>单元初始國值电压的不同以及氧化层厚度的不同都会引起擦除操作结束 时國值电压的不同。这⼀点可以从两⽅⾯来弥补：(1）在应⽤擦除脉冲之前，将阵列中的所有单 元都编程，以使所有的⽹值都从⼤致相同的值开始。(2)在此之后加上⼀个可控制宽度的擦除脉 冲。接着读整个阵列以检查这些单元是否已被擦除。如果尚末全部擦除，则再应⽤另⼀个擦除 豚冲，接着又是⼀个读周期。如此进⾏下去，直⾄所有单元的國值电压都低于所要求的电平。⼀ 般擦除时间在100 ms 到1s之间。

![[support/img/Pasted image 20240114133452.png|400]]
**对于写(编程)操作(b)**：<font color="#ff0000">把⼀个⾼电压脉冲加在所选器件的栅上。</font>如果这时在漏端加上“1”，就会产⽣热电⼦并将其注⼈浮栅上，使國值电压上升（相当于使 其变为⼀个总是关断的器件）。如果不加“1”，则浮栅仍保持在原来没有电⼦的状态，即相当于"0”状态。
•栅加高压（12V）、源端接地、漏端加6V （‘1’）或接地（“0’） 
•热电子注入 
•编程时间约10us
> 为使國值电压按所需从3 V变化⾄3.5 V，⼀般必须加上范围在 1~10 us 的脉冲。


![[support/img/Pasted image 20240114133500.png|400]]
==这个图的意思就是, S是0, 电子要走, 能去哪里, 只能去浮栅, 但只能通过D, 因此D开开之后, 就是开门了, D接1了, 这样就是电子进入浮栅, 阈值电压变高了.==

**读操作**(c): 过程与所有的 NOR ROM 结构⼀样。为选择⼀个单元，将
- 字线上升⾄5 V，使位线有条件地放电。
![[support/img/Pasted image 20240114133514.png|400]]
#### C:NAND型Flash存储器模块
🏀**为什么需要NAND???**
因为: NOR 结构使随机读取时间很快。与此同时，由于需要精确地控制國值电压，它的擦除和编 程时间却很慢。这些特性使这类 Plash 存储器(闪存）⽐较适合于存放程序代码这类的应⽤。其他 ⼀些应⽤如视频或⾳频类存储器等并不需要快速的随机存取，但却需要有较⼤的存储密度(降低 存储器成本）、快速的擦除、编程以及快速的串⾏存取。对这些要求采⽤前⾯描述的 NAND ROM 结构更为适宜，因此有许多Plash 存储器的制造商已采⽤这⼀拓扑结构。<span style="background:#d3f8b6">(为啥NAND就快啊)</span>
![[support/img/Pasted image 20240114134348.png|500]]
变化在于, 编程的时候从热电子注入变成FN了, 和EEPROM一样了.
那为啥会有这个变化呢?在之前, 编程需要给12,0,6(0),在这里直接一个20就往上写.那为啥之前需要呢12,6,0呢, 因为要利用D来注入电子.
> ==擦除的时候, 我直接干个过分的, 我直接擦成耗尽型, 也就是直接干导通了, 因为本来NAND的字线只有一个为0, 其余全是1, 也就是其余的本来就该导通对吧. 当我需要写的时候, 那我想把耗尽型掰回来, 也就是, 电子拉到栅极, 也就是晶体管废了, 阈值高了==, *我隧穿是一定可以做到这一点的*, 肯定不会掰不回来, 所以我肯定可以关断, 因此, 功能就不会错, 只要关断, 立马拉低不了, 因此位线就输出1了, 也就写入了一个1. 

> [!question] 面积不变大?和EEPROM啥区别?
> *????*

### (5)小结
![[support/img/Pasted image 20240114142037.png]]
- *EEPROM结构的灵活性以密度和性能为代价*
- *EPROM和Flash在密度和速度上相当, Flash的适应性和可靠性高*
- *编程时都要求在字线和位线上有高压信号（12~20V）*
## 3.SRAM
存储单元的读写性能（速度）大致相当
- 静态随机存取存储器(SRAM)
	- 电源电压维持期间数据可长时间保持
	-  单元面积大 ( 6个晶体管 / 单元 )
	-  速度快
	-  差分输出
- 动态随机存取存储器(DRAM)
	- 需要周期刷新
	- 单元面积小 ( 1~3个晶体管 / 单元 )
	- 速度较慢
	- 单端输出
🏀**6 管SRAM单元**
- *双位线结构，可提高读写操作时的噪声容限* 
- *对比书249页，图7.21： CMOS SR触发器*
![[support/img/Pasted image 20240114142356.png|500]]
### (1)CMOS SRAM读操作
![[support/img/Pasted image 20240114143733.png]]
![[support/img/Pasted image 20240114143748.png]]
读出时CMOS SRAM单元简化模型(Q=1, $\mathbf{V}_{\mathrm{precharge}}=\mathbf{V}_{\mathrm{DD}})$

$$
k_{n,\:M5}\bigg((V_{DD}-\Delta V-V_{Tn})V_{DSATn}-\frac{V_{DSATn}^{2}}{2}\bigg)=k_{n,\:M1}\bigg((V_{DD}-V_{Tn})\Delta V-\frac{\Delta V^{2}}{2}\bigg)
$$

^179522

$$
\Delta V=\frac{V_{DSATn}+CR(V_{DD}-V_{Tn})-\sqrt{V_{DSATn}^{2}(1+CR)+CR^{2}(V_{DD}-V_{Tn})^{2}}}{CR}\quad CR=\frac{W_{1}/L_{1}}{W_{5}/L_{5}}
$$
![[support/img/Pasted image 20240114143944.png]]
![[support/img/Pasted image 20240114144006.png]]
### (2)CMOS SRAM写操作
![[support/img/Pasted image 20240114144428.png]]
![[support/img/Pasted image 20240114144443.png]]
![[support/img/Pasted image 20240114144506.png|500]]
### (3) 6 管的尺寸设计
#👁 
![[support/img/Pasted image 20240114144528.png|500]]
==右边是一组, 左边是一组==
### (4) 6 管SRAM单元版图
<font color="#bfbfbf">六管SRAM 单元虽然简单可靠，但占⽤较⼤的⾯积。除器件本⾝ 之外，它还要求有信号布线及连接到两条位线、⼀条字线以及两条电源轨线上。把两个 PMOS 晶 体管放在 N阱中也占⽤了不少⾯积。图 12.31 是这样⼀个单元可能的版图。它的尺⼨取决于布线和⼯艺层间的接触孔(有11.5个接触孔—顶部和底部的接触孔只算⼀半，因为它们与相邻的单元共享）以及阱所要求的最⼩空间。</font>
![[support/img/Pasted image 20240114144700.png|500]]
### (5)电阻负载SRAM单元

![[support/img/Pasted image 20240114144826.png|500]]
<span style="background:#d3f8b6">考虑图 12.32 中称为电阻负载 SRAM 单元(也称为四管 SRAM 单元）的电路图。这⼀单元的 特点是⽤⼀对电阻负载NMOS 反相器来代替原来的⼀对交叉男合 CMOS 反相器。即⽤电阻来代 替PMOS 管，因⽽简化了布线。这使 SRAM 单元的尺⼨缩⼩了约 1/3，如表12.2中IMb SRAM 的 例⼦所示。</span>
> 意思是, 上拉的时候, 我冲到1了, 直接Q就由BL传过来了, 不需要通过RL进行上拉, 所以RL很大也没关系.(<span style="background:#d3f8b6">之前不一致都这样???</span>)
> 静态功耗的意思是: Q=1的时候, 左边M1导通, 那我Q非那条路就会放电, 因此有功耗, 所以**RL应该大,有个下限**
> 从放电动态来讲, 我等于1的那个节点, 怎么着也会放电, 因为下边有漏电流, 而又通过RL充电, 这个充电的电流要比下边的漏电流大两个数量级, 所以**RL也有的上限**
![[support/img/Pasted image 20240114145048.png]]

## 4.DRAM
在讨论电阻负载 SRAM 单元时，==我们注意到负载电阻的唯⼀功能是补充由于漏电造成的电荷损失。==⼀种办法是完全取消这些负载并通过周期性地重写这个单元的内容来补偿电荷损失。 这⼀刷新操作包括读单元的内容以及随后进⾏的写操作，它应当经常发⽣以保证存储单元的内 容次不会因漏电⽽丢失。⼀般来说，刷新应当每1ms ⾄4 ms 发⽣⼀次。对于容量较⼤的存储器 来说，单元复杂性的降低⾜以补偿因刷新要求所增加的系统复杂性。这些存储器称为动态存储 器，因为这些单元的⼯作原理是基于在电容上存储电荷。
### (1)3TDRAM
![[support/img/Pasted image 20240114150853.png]]
![[support/img/Pasted image 20240114150945.png]]
![[support/img/Pasted image 20240114151045.png|500]]
![[support/img/Pasted image 20240114151243.png]]
- 此外还有一段合并字线的讨论: 如果以更为复杂的电路操作为代价，那么单元结构还可以进⼀步简化。例如，<font color="#ff0000">可以把 BLI 和 B12 合并为⼀条线</font>。此时，读和写周期仍可以如前所述那样进⾏。但<font color="#ff0000">读-放⼤-写</font>刷新周期必领交 替进⾏，因为从单元读出的数据值是所存放数据值的反信号。这就要求位线在⼀个周期内被驱动⾄两个值。另⼀种⽅法是<font color="#ff0000">合并 RWL和WWL线。</font>同样，<font color="#ff0000">这对单元的操作没有本质的改变</font>。⼀个 读操作⾃动伴随对该单元内容的刷新。<span style="background:#d3f8b6">但这⼀⽅法需要仔细控制字线电压时序，以防⽌刷新期间在 读出单元的实际值之前就已出现写单元操作。</span>
> [!question] 自举??嵌入式??
> <span style="background:#d3f8b6">????</span>
### (2)1TDRAM
![[support/img/Pasted image 20240114151555.png]]
![[support/img/Pasted image 20240114151605.png]]
![[support/img/Pasted image 20240114151617.png|500]]
原理其实不简单, 当写入的时候, WL=1, 此时BL的1或者0被写入Cs
读的时候, <font color="#ff0000">CBL冲到一个中间电平</font>, WL一等于1, 0就把VPRE拉低, 反之, 之后放大这个摆幅就可以了.
![[support/img/Pasted image 20240114152428.png|500]]
**特点**
- 单管DRAM的每根位线需要一个灵敏放大器（电荷重新分 配的读出方式）
- 另外，值得注意的是，与两条位线上同时存在数据值及其反信号值的 SRAM 不同，DRAM 存储单元是单端的。正如将在 12.3 节中讨论的，这会使灵敏放⼤器的设计复杂化。
- 单管DRAM单元的读出是破坏性的，读出时需要进行刷新
- 单管单元需要设计一个额外的电容
- 对DRAM单元写入‘1’时，有阈值损失。可以通过对字 线施加一个高于VDD的电压值来克服
**微观结构**
![[support/img/Pasted image 20240114152753.png]]
![[support/img/Pasted image 20240114152609.png|500]]
![[support/img/Pasted image 20240114152809.png]]
![[support/img/Pasted image 20240114152618.png|500]]

# 四、外围电路（Periphery）
![[support/img/Pasted image 20240114152704.png|500]]

# 五、可靠性（Reliability）
![[support/img/Pasted image 20240114152712.png|500]]
# 六、总结
![[support/img/Pasted image 20240114152725.png|500]]
