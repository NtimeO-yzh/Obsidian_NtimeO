---
tags:
  - notebook
---
 ### 运算:
![[support/img/Pasted image 20240103172434.png|600]]
#### 算术操作符
**a * b 乘**
**a / b 除**
**a + b 加**
**a - b 减**
==**a ** b 求幂**==
==**a % b 取模**==
> [!danger] 注意 1.1
> - *无符号数乘法*时，结果变量位宽应该为 2 个操作数位宽之和。例如a 为[1:0], b 为[2:0], ==sum应该为[4:0]==
> - 负数表示时，可以直接在十进制数字前面增加一个减号 -，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。==(因此, 写负数的时候指定位宽)==
``` verilog
mula = -4'd4 ;
mulb = 2 ;
res = mula * mulb ;      //计算结果为res=-6'd8, 即res=6'h38，正常
res = mula * (-'d4) ;    //(4的32次幂-4) * 2, 结果异常
```
#### 关系操作符
**关系操作符有大于（>），小于（<），大于等于（>=），小于等于（<=）。**
关系操作符的正常结果有 2 种，真（1）或假（0）。
如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。
#### 等价操作符
**等价操作符包括逻辑相等（\==），逻辑不等（!=），全等（\=\==），非全等（!\==）。**
等价操作符的正常结果有 2 种：为真（1）或假（0）。
逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。
全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：
``` verilog
A = 4 ;
B = 8'h04 ;
C = 4'bxxxx ;
D = 4'hx ;
A == B        //为真
A == (B + 1)  //为假
A == C        //为X，不确定
A === C       //为假，返回值为0
C === D       //为真，返回值为1
```
#### 逻辑操作符
**逻辑操作符主要有 3 个：&&（逻辑与）, ||（逻辑或），!（逻辑非）。**
逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。
如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。
如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。
逻辑操作符的操作数可以为变量，也可以为表达式。例如：
``` verilog
A = 3; 
B = 0; 
C = 2'b1x ;
    
A && B    //     为假
A || B    //     为真
! A       //     为假
! B       //     为真
A && C    //     为X，不确定
A || C    //     为真，因为A为真
(A==2) && (! B)  //为真，此时第一个操作数为表达式
```
#### 按位操作符
**按位操作符包括：取反（~），与（&），或（|），异或（^），同或（~^）。**
按位操作符对 2 个操作数的每 1bit 数据进行按位操作。
如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。
取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。
下图给出了按位操作符的逻辑规则。
![[support/img/Pasted image 20240103173656.png|600]]
``` verilog
A = 4'b0101 ;
B = 4'b1001 ;
C = 4'bx010 ;
    
~A        //4'b1010
A & B     //4'b0001
A | B     //4'b1101
A^B       //4'b1100
A ~^ B    //4'b0011
B | C     //4'b1011
B&C       //4'bx000
```
#### 移位操作符
**移位操作符包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）。**
移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。
算术左移和逻辑左移时，右边低位会补 0。
逻辑右移时，左边高位会补 0；<font color="#ff0000">而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</font>
``` verilog
A = 4'b1100 ;
B = 4'b0010 ;
A = A >> 2 ;        //结果为 4'b0011
A = A << 1;         //结果为 4'b1000
A = A <<< 1 ;       //结果为 4'b1000
C = B + (A>>>2);    //结果为 2 + (-4/4) = 1, 4'b0001
````
#### 拼接操作符
**拼接操作符用大括号 {，} 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。**
拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：
``` verilog
A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
```
#### 归约操作符
归约操作符包括：归约与（&），归约与非（~&），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。
归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。
逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。==区分这些操作符的关键是分清操作数的数目==，和计算结果的规则。
``` verilog
A = 4'b1010 ;
&A ;      //结果为 1 & 0 & 1 & 0 = 1'b0，可用来判断变量A是否全1
~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1'b0, 可用来判断变量A是否为全0
^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1'b0

````
### 标点
- Module modulename(input ...)只有最后一个变量后边不加逗号
- Module modulename(input ...)后边加分号
- \`timesacle 后边没分号, 前边是左上角那个倒引号, 不是单引号
- 一个 always 块没分号
- endmodule 更没分号
- case 后边跟 endcase
- alway 后边跟 begin end
- Always 后边的敏感电平列表用逗号隔开`always @(posedge clk, negedge rst)`

### 模块例化
以前的名字  新模块的名字(参数列表)
参数列表有两种命名规则
1. 按照顺序
2. 不按照顺序
```Verilog
module sub_mod(
	input clk,
	input rst_n,
	input [7:0]a,
	input [7:0]b,
	output reg [7:0] c1
);
//first
sub_mod which_bigger(clk,rst_n,a,b,big1);
//second
sub_mod which_bigger1(.rst_n (rst_n),.a (a),.b (c),.c1 (big2), .clk (clk));
```

### Memory
Verilog中提供了两维数组来帮助我们建立内存的行为模型。具体来说，就是可以将内存定义为一个reg类型的数组，这个数组中的任何一个单元都可以通过一个下标去访问。这样的数组的定义方式如

1. 数组（内存）定义

```java
	reg [wordsize : 0] array_name [0 : arraysize];
```

例如：

```java
	reg [7:0] my_memory[0:255];
```

其中 **[7:0]** 是**内存的宽度（位宽）**，而 **[0:255]** 则是 **内存的深度**（也就是有多少存储单元），其中宽度为8位，深度为256。地址0对应着数组中的0存储单元。

2. **写操作**：如果要存储一个值到某个单元中去，可以这样做：

```java
	my_memory[address] = data_in;
```

3. **读操作**： 而如果要从某个单元读出值，可以这么做：

```java
 	data_out = my_memory[address];
```
4. **读取内存中的某一位或者多位**  
    只需要读一位或者多个位，就要麻烦一点，因为Verilog不允许读/写一个位。这时，就需要使用一个变量转换一下：
    
    例如：
    
```java
    data_out = my_memory[address];
	data_out_it_0 = data_out[0];
```

这里首先从一个单元里面读出数据，然后再取出读出的数据的某一位的值

5. **内存的初始化定义**  
    初始化内存有多种方式，这里介绍的是使用 **$ readmemb** 和 **$ readmemh**系统任务来将保存在文件中的数据填充到内存单元中去。  
    **$ readmemb** 和 **$ readmemh**是类似的，不过 **$ readmemb** 用于 **内存的二进制** 表示，而 **$ readmemh** 则用于**内存内容的16进制** 表示。这里以$readmemh系统任务来介绍。  
    具体语法：

```java
	$readmemh("file_name", mem_array, start_addr, stop_addr);
```

需要注意的是：  
**file_name**是包含数据的文本文件名，**mem_array**是要初始化的内存单元数组名，**start_addr** 和 **stop_addr**是可选的，指示要初始化单元的起始地址和结束地址。

6. **内存的初始化例子**

```java
module  memory ();
reg [7:0] my_memory [0:255];
 
initial begin
$readmemh("memory.list", my_memory);
end

endmodule
```

这里使用内存文件memory.list来初始化my_memory数组。