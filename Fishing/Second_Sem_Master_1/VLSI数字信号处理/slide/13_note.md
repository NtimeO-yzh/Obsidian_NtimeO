# 数字强度缩减
# 引言
- DSP计算强度的缩减
	- 算法级强度缩减(第9章，未讲)：用来减少加法和乘法次数
	- 数字级强度缩减(本章内容)：用来减少硬件实现复杂度的 数字变换技术
- 子表达式消除与子结构共享的概念
	- 子表达式消除(subexpression elimination)方法：重组计算， 改善计算性能
	- 子结构共享(substructure sharing)：子结构对应于冗余的 子表达式
- 应用
	- 多常数乘法：如线性变换、多项式求值
	- 数字滤波器中的子表达式共享
	- 线性变换中的数字分拆(不讲)
		- 加性数字分拆
		- 乘性数字分拆
- 重温位串行常数乘法器
	- 缩放算子$2^{-i}$即右移i位操作
		- 缩放算子表示为i个寄存器(延迟元件 ＋开关
	- 常数乘法器即移位加法器组
		- 几种移位－加(减)的组态
![[support/img/Pasted image 20240527225202.png|500]]
# 子表达式消除
- 是用于常数乘法的一种数字变换
	- 仅能用于常数乘法：如ax, bx, cx等，对x做(移位-加)操作
	- 目标：找出其中的冗余操作过程，在计算中共享，使(移 位-加)次数最小化
	- 冗余操作：指存在于常数a, b, c,…位级表示中相同的子表 达式，消除这些子表达式的重复运算
- 例子: *==常数乘法ax和bx两个计算操作==*
	- 设a = 13 = 001101, b = 27 = 011011
		其中$ax$需要两次移位和两次加法, 三个1要加两次, 个位的1不需要移位
		$bx$需要三次移位和三次加法
		两个操作共需要五次移位和五次加法
	- a和b的子表达式消除: 
		1001\[(x<<3)+x]，1次移位和1次加
		a=000100+001001=4+9, b=010010+001001=18+9=2\*9+9, 因此分别带入a和b则有
		ax=000100x+001001x，再多1次移位1次加
		bx=010010x+001001x=001001x<<1+001001x，再多1次移位1次加
		总共只需要3次移位和3次加
		
# 多常数乘法(MCM)
### 多个常数与一个公共变量的乘法
- 问题：计算多个常数与一个公共变量的乘法ax, bx, cx
- 目标：采用子表达式消除使总的移位和加法次数最少
- 算法：迭代匹配(iterative matching)处理，5个基本步骤
	1. 用二进制数(2的补码或CSD)表示各常数
	2. 计算各常数间的按位匹配数(非零数)
	3. 选择匹配最多者，得到冗余的子表达式
	4. 从相应常数中消除该子表达式，返回剩余值
	5. 重复步骤2、3、4，直至无法改进
#### 例子
ax, bx, cx，其中a=237, b=182, c=93
1. 2进制表示：a =11101101， b=10110110， c=01011101
2. 计算a, b, c之间的按位匹配数, a与b → 3，b与c → 2，a与c → 4
![[support/img/Pasted image 20240528105129.png|127]]
3. 选择匹配数最多者(a与c → 4)：sub1=01001101=77→a与c的子表达式→3次移位和3次加
4. 计算a、c的余值![[support/img/Pasted image 20240528105252.png|201]]
5. 继续对新的数字做上述处理: 匹配数最多者a与b → 2，冗余的 子表达式为sub2=10100000=160 2次移位和1次加
6. 计算a、b的余值：右图下表![[support/img/Pasted image 20240528105342.png|224]]
7. 没有进一步的冗余子表达式
8. 新计算量统计：9次移位9次加
	- sub1和sub2(共5移4加)
		- sub1(3移3加)
		- sub2(2移1加)
	- a=sub1+sub2(1加)
	- b=(00010110)+sub2(3移3加)
	- c=sub1+(00010000) (1移1加)
9. 计算量比较
	- 原计算：需要14次移位和13次加
	- 子表达式消除后：需要9次移位和9次加
### 线性变换：矩阵矢量乘
- 一般形式：y=T\*x，其中T是mxn维矩阵![[support/img/Pasted image 20240528110056.png]]
- 可分三个步骤完成子表达式消除
	1. 利用迭代匹配使每列运算中需要的(移位-加)次数最小化
	2. 利用子表达式产生中间积
	3. 共享中间积，计算 最终结果
#### 例子
![[support/img/Pasted image 20240528110319.png|270]]
1. 利用迭代匹配算法，找到各列子表达式(7次)
**0101**: ***0010*** **1100** *0000* *0010* 第一列
**1011**: **1000** *0000* 1000 *0000* 第二列
**0010**: 0000 **0101** 0000 0101 第三列
**1001**: 0100 0100 0110 0010→ **0100**: 0000 0000 0010 **0010** 第四列
![[support/img/Pasted image 20240528112431.png|293]]
2. 利用右表计算出10个中间积$p_i$， 并写出需要计算的式子![[support/img/Pasted image 20240528112525.png|408]]
3. 将yi用(pi)的运算组合表示![[support/img/Pasted image 20240528112624.png|431]]
4. 再利用子表达式消除方法进一步对\面需要计算的式子 做 简化(层次化子表达式消除)。最终结果如下(13次)![[support/img/Pasted image 20240528112701.png|362]]
### 多项式求值问题
各项公共变量的幂指数是常数的求幂计算![[support/img/Pasted image 20240528112955.png|224]]
直接计算各项的话，需要12+6+3+1=22次乘法
#### 例子
- 用子表达式消除方法降低计算量
	1. 首先：把各个常指数表示为二进制数: 1=0001，2=0010， 4=0100，7=0111，13=1101
	2. 找出并计算出它们的冗余![[support/img/Pasted image 20240528113059.png|431]]
	3. 可得计算方法如下：再多3次乘![[support/img/Pasted image 20240528113132.png|431]]
	4. 22次乘法→6次乘法
	5. ![[support/img/Pasted image 20240528113331.png|201]]
---

- 单个多项式求值：层次化子表达式消除
	1. 先减少各次幂所需乘法次数
	2. 再减少各常系数乘所需要的移位加次数
#### 例子
多个多项式求值：如下面三个多项式的求值
![[support/img/Pasted image 20240528113505.png|339]]
可以应用子表达式消除方法，分两个层次，缩减其 计算量
1. 层次1：令$x_1=x^1, x_2=x^2, x_3=x^3, x_4=x^4, x_5=x^5$, 可由4次乘法得到
2. 层次2：计算如右3个多项式![[support/img/Pasted image 20240528113627.png|247]]相当于线性变换：y=T\*x
3. 对应的T如右下![[support/img/Pasted image 20240528113651.png|215]]采用前述的线性变换的步骤
4. 总加法次数: 27→20

# 数字滤波器中的子表达式共享
![[support/img/Pasted image 20240528114008.png]]
![[support/img/Pasted image 20240528114230.png]]![[support/img/Pasted image 20240528120230.png]]
![[support/img/Pasted image 20240528120355.png]]![[support/img/Pasted image 20240528120531.png]]
![[support/img/Pasted image 20240528120605.png]]
![[support/img/Pasted image 20240528120629.png]]

# 数字拆分(略)

# 小结
![[support/img/Pasted image 20240528120821.png]]
# 题目
![[support/img/Pasted image 20240528120801.png]]![[support/img/Pasted image 20240528120807.png]]![[support/img/Pasted image 20240528120838.png]]
![[support/img/Pasted image 20240528132802.png]]