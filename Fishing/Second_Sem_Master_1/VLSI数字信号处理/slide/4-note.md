**重定时的定义:** 是一种变换技术, 在不改变系统功能的情况下, 改变电路延迟原件的配置.
**重定时的作用:** 
1. 改变关键路径或时钟周期
2. 改变锁存器数目
3. 减少开关动作, 降低功耗
**重定时的描述:**
(1)重定时变换: 将一个电路拓扑$G$映射到一个重定时电路$G_{r}$
(2)重定时值(解): 节点V的重定时值$r(V)$的集合构成重定时解.
(3)重定时方程: 用来确定节点U到V的边重定时之后的权重(延迟数)
- 有向边e的权重: 该有向边的延迟数
- 重定时前后, 有向边的权重分别表示为$w(e)和w_{r}(e)$
- 重定时方程: $$w_{r}(e)=w(e)+[r(V)-r(U)]$$
(4)重定时的性质
1. 某一个路径集合, 其重定时厚的权重只与路径的起点和终点有关
2. 环路的重定时后, 总延迟数不变
3. 迭代边界不变
4. 重定时值平移: 所有节点的r值都增加常数j, **==重定时映射不变==**
# 重定时求解方法
## 定义
1. 最小可用时钟周期：$$Q(G){=}\max\{t(p){:}w(p){=}0\}$$其中G由关键路径决定. 意思是, 电路G分布的所有使得Delay为0的p路径的用时.
2. $W(U, V)$: 节点U到V的所有路径中的最少延迟数$$\begin{array}{rcl}W(U,V)&=&\min\{w(p):U\overset{p}{\operatorname*{\leadsto}}V\}\end{array}$$
3. $D(U, V)$: U到V权重为W(U, V)的路径中的最长计算时间$$D(U,V)=\operatorname*{max}\{t(p):U\stackrel{p}{\leadsto}V\mathrm{~and~}w(p)=W(U,V)\}$$
## 方法
### 第一步
设定最小可用时钟周期目标，使$\Phi(G_{r_0}){=}c\leq\Phi(G_r),\Phi$表示时钟周期 
### 第二步
$计算W(U, V)和D(U, V)$
> 可以用算法得到, 可以从G中直接获得
### 第三步
确定系统对重定时的约束条件，用于建立不等式方程组，寻找达到期望最小可用时钟周期c的一个重定时值解r0
1. 可行性约束: $w_{r}(e)=w(e)+[r(V)-r(U)]\geq 0$, 因此有$$r(U)-r(V)\leq w(e)$$
2. 关键路径约束: 对$G$中所有节点对$(U,V)$, 若$D(U,V)$>c, 则要求$r(U)-r(V)\leq W(U,V)$-1, 即$W(U,V)+r(V)$-$r(U)\geq1]$
> 解释, D(U,V)比想要的最小时钟周期大, 那就说明从U到V之间存在一个没有D的路径使得关键路径太长了, 因此要求至少加一个D

**==那万一加一个也不行呢?==**
### 第四步
简化相同的约束, $比如A-B<3和A-B<0同时存在的时候保留后者, 但是B-A就是另外的约束了$
### 第五步
画出约束关系图:
1. $A-B\leq 3$就是画一条$U\to V$的边, 其延时数为3. 要是大于等于, 一样画成这种形式的
2. 画一个额外节点$A1$, 而且$A1\to 每个节点$的距离都是0
### 第六步
使用Bellman-Ford算法或者Floyd-Warshall算法
以后者为例子,
1. 每一个矩阵元代表$节点i\to 节点j, 经过(阶数-1)$个节点的最短路径, 无路径长度为$\infty$
2. 使用类似LPM的递推方法, 第一个矩阵的行和第二个矩阵的列相加, 但是不同的是, 取的是$min\{相加元素的最小值, 加数矩阵该矩阵元的值\}$
3. 最后一个矩阵, 也就是$节点个数(包括A1)+1$个矩阵的2最后一行除了最后一个元素, 其余的就是对应的r值**==(对角线没有负数)==**
4. 带入公式$$w_{r}(e)=w(e)+[r(V)-r(U)]$$得到新的$w(e)$