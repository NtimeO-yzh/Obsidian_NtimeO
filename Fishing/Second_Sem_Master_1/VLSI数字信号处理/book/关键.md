# 第一章
## 1.对于框图的理解
框图就是使用一系列的功能模块和有向线段来表示DSP算法的功能.以课本上的例子为例, 对于三阶FIR数字滤波器: $$y(n)=b_{0}x(n)+b_{1}x(n-1)+b_{2}x(n-2)$$
最关键的就是, 我如何去表达$y(n)$是由之前的输入样本点(也就是$x(n-1),x(n-2))$组成的. 在实现的意义上来说, 需要一个功能模块, 其提供了一个单位延迟(以输入样本点的均匀间隔来度量这一"单位"), 使得进去的是$x(n)$但是出来的就是$x(n-1)$. *==那么这么一个模块的物理实现是什么样的呢: 很容易想到, 就是一个寄存器.==*
这样, 也可以理解课本中的这样一段话:
> 组合逻辑的*关键路径*定义为输入与输出之间的最长路径, 在这里的路径长度正比于他的运算时间. DSP系统通常使用时序电路实现, 则此处的关键路径定义为任意两个延时单元之间的最长路径.

也就是说, 关键路径是针对组合逻辑来说的, 虽然我组合逻辑也有延时, 但是不是那个固定的单位延时, 而我两个单位延时单元之间走的长度决定了我时钟可以最快多快, 要是时钟比这个还快, 我的两个存储单元之间的路还没有走完, 那我的数据就过去了, 那肯定是错的数据. 这就是为什么:
> 关键路径的运算时间确定了DSP系统的*最小可行时钟周期*.

## 2.关键概念
1. *DSP*: Digital Signal Process 数字信号处理
2. *FIR*: Finite Impulse Response 有限冲激响应
3. *IIR*: Finite Impulse Response 无限冲激响应
4. *LTI*: Linear Time-Invariant 线性时不变
5. *迭代*: DSP算法的所有计算执行一次成为一次迭代
6. *迭代周期*: 算法执行一次迭代所需要的执行时间
7. *迭代率*: 迭代周期的倒数
8. *迟滞*: 系统接受输入与产生对应输出之间的时间差.
## 3.DFG基本知识
Data-Flow Graph, 节点表示运算,功能或子任务, 有向边表示数据通路, 每条边有一个非负的延时数与之相关. 与节点相关的称为执行时间.
DFG中的任意节点一旦它的所有输入数据准备好时就可以启动. 也就是说, 没有输入边的节点可以在**任意时刻**启动, 因此很多节点可以同时启动, 从而具有并发性. 反过来说, 一个带有多条输入边的节点只有所的前节点都启动后才能启动,**=={如何理解这里和无休止程序之间的关系}==**这也给DFG施加了*优先级约束*的概念, 分为*迭代内优先级约束*和*迭代间优先级约束*.

# 第二章
## 1.基本过程
很多DSP算法, 比如递归数字滤波器和自适应数字滤波器都包含有*反馈回路*, 因此对于可实现系统, 迭代以及采样周期存在其内的最低边界.这种边界被称为*迭代周期边界*, 或者简称为*迭代边界*. **=={反馈回路的例子是什么, 为什么因此上了}==**
DFG分为递归的和非递归的, 非递归DFG不包含环路, 而递归DFG至少包含一个环路. 递归DFG存在着一个基本极限, 该极限表示了关于用硬件实现基本的DSP程序能有多快, 这个极限称为迭代边界.
*环路*是指起点和重点都是同一个节点的有向路径. **执行一个环路所需要的时间可以由DFG中的边所描述的优先级关系来确定**.*环路边界*表示环路运行的时间的最低限制, 规范表达如下:$$loop\_{bound}=\frac{t_{1}}{w_{1}}$$
- $t_{1}$: 环路运行时间;
- $w_1$:环路延时数目.

*关键环路==的环路边界就是DSP迭代边界, 其是迭代或者采样周期的最低限制, 与可用的运算资源多少无关==*.**=={采样周期??}==**
## 2.最长路径矩阵算法LPM
### (1)算法流程
1. 对DFG中所有边的d个延迟元件顺序编号1, 2, …, d，构建新图$G_d$
2. $\text{以延迟元编号}\boldsymbol{m}\text{为右上标}(\text{阶),构成一系列矩阵}L^{(m)},\boldsymbol{m}=\boldsymbol{1},...,\boldsymbol{d}$
	1. $d\times d$维矩阵
	2. $第i行第j列个元素l_{ij}表示:  从延迟元件d_i到d_j的所有存在的路径中的最长者之值$
	3. 所有路径都经过$(m-1)$个延迟元件
	4. 若路径不存在, 就赋值$-1$
3. 高阶矩阵递推公式: $$l_{ij}^{(m+1)}=max(-1,l_{ik}^{(1)}+l_{kj}^{(m)}),k\in K$$
	- 其中, K是使得路径存在的k值的集合, 也就是说$l_{ik}^{(1)}和l_{kj}^{(m)}$都不为$-1$
4. ${\text{迭代边界}T}_{\infty}只考虑所有矩阵的所有对角元，其中最大者$$$T_\infty{=}\mathrm{max}\{l_{ii}^{(m)}/m\},\mathrm{for~i},m\in\{1,2,...,d\}$$
### (2)例子

[[Fishing/Second_Sem_Master_1/VLSI数字信号处理/slide/2-note#LPM算法例子|LPM算法示例]]
## 3.几个时间的关系
1. 迭代周期$T_{it}$: 处理1个输入样点所用迭代时间
2. 系统时钟周期$T_{clock}$: 由关键路径的执行时间$T_c$决定, $T_{clock}>T_{c}$
3. *采样周期*$T_s$: 对于实时要求, 必须要求$T_{s}\geq T_{it}$

对于*非并行系统*, 每次迭代输入1个样点, 因此有$T_{it}=T_{clock}$
# 第三章 流水线与并行处理

## 1.基本思路
对于实时要求, 必须要求$T_{s}\geq T_{it}$. 但是呢, 这个系统比较菜, 导致sample来的时间内, 我一次迭代还跑不完呢, 也就是迭代周期$T_{it}$太大. 因此需要特殊的方法降低迭代周期$T_{it}$. 因此有两种基本方法:
1. *流水线*
2. 并行处理
## 2.流水线
流水线技术的基本思路: 通过对关键路径适当插入锁存器来减少$T_{c}$从而减少$T_{clock}$, 从而减少$T_{it}$. 但是仍然不改变非并行的特点.
### (1)如何适当插入
*割集*：指图被线割切到的一组边，若从图中移走这些边，则图被拆 为互不相连的两个子图或孤立节点。(割切线是广义闭合的：线、环)
*前馈割集*：数据沿割集所有边前(同)向移动
*==插入原则: 必须在前馈割集的所有边插入==*
**要想将迭代周期减少到最小值**:就要不断适当插入, 达到每条有向边上都有D
> [!question] bubble
> 并行就能没有bubble的问题吗?

### (2)细粒度流水线
###  (3)转置法
## 3.并行处理
没什么可说的, PPT上讲得很好了
## 4.流水线与并行处理用于降低功耗
由于上课没有仔细听, 因此进行整理
[[Fishing/Second_Sem_Master_1/VLSI数字信号处理/slide/3-note|3-note]]