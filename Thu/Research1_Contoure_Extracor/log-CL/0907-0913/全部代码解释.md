```python
from skimage import morphology  
import numpy as np  
import matplotlib.pyplot as plt  
import datetime  
  
def Titer(img):  
    # python-otsu  
    def OTSU(img_gray, L, R):  
        img_gray = np.array(img_gray).ravel().astype(np.uint8)  # 变数组  
        ret = 0  
        PixSum = img_gray.size  # 总的像素数目=数组长度  
        PixCount = np.zeros(256)  # 各个灰度值的像素数目  
        PixRate = np.zeros(256)  # 各灰度值所占总像素数的比例  
        for i in range(PixSum):  # 统计各个灰度值的像素个数  
            # 默认灰度图像的像素值范围为GrayScale  
            Pixvalue = img_gray[i]  
            PixCount[Pixvalue] = PixCount[Pixvalue] + 1  
        for j in range(256):  
            PixRate[j] = PixCount[j] * 1.0 / PixSum  
        # 确定最大类间方差对应的阈值  
        Max_var = 0  
        for i in range(L, R):  # 从1开始是为了避免w1为0.  
            u1_tem = 0.0  
            u2_tem = 0.0  
            # 背景像素的比列  
            w1 = np.sum(PixRate[L:i]) / np.sum(PixRate[L:R])  
            # 前景像素的比例  
            w2 = np.sum(PixRate[i:R]) / np.sum(PixRate[L:R])  
            if w1 == 0 or w2 == 0:  
                pass  
            else:  # 背景像素的平均灰度值  
                for m in range(L, i):  
                    u1_tem = u1_tem + PixRate[m] * m  
                u1 = u1_tem * 1.0 / w1  
                # 前景像素的平均灰度值  
                for n in range(i, R):  
                    u2_tem = u2_tem + PixRate[n] * n  
                u2 = u2_tem / w2  
                # print(u1,u2)  
                # 类间方差公式：G=w1*w2*(u1-u2)**2  
                tem_var = w1 * w2 * np.power((u1 - u2), 2)  
                # print(tem_var)  
                # 判断当前类间方差是否为最大值。  
                if Max_var < tem_var:  
                    Max_var = tem_var  
                    ret = i  
        return ret  
    num_sum = img.size  
    hist = cv2.calcHist([img], [0], None, [256], [0, 256])  # hist是256x1的数组，每个值对应于该图像中具有相应像素值的像素数  
    x = np.arange(256)  
    hist = hist.flatten()  # 列向量变数组  
    y = np.array(hist)  
    y = y.astype(int)  
  
    # 直方图滤波  
    y_01 = np.arange(256)  
    co_cal = [1 / 16, 1 / 16, 1 / 8, 1 / 4, 0, 1 / 4, 1 / 8, 1 / 16, 1 / 16]  
    for i in x:  
        if i <= 4:  
            la = i  
        else:  
            la = 4  
        if i + 4 >= 255:  
            rb = 255 - i  
        else:  
            rb = 4  
        y_01[i] = sum(co_cal[4 - la:4 + rb + 1] * y[i - la:i + rb + 1])  
        if i == 255:  
            break  
    y_01[0] = int(0.5*y[0]) + y_01[0]  
    y_01[255] = int(0.5 * y[255]) + y_01[255]  
    # plt.bar(x, y_01)  
    # plt.show()  
    # 寻找峰值  
    range1 = 8  # 为了减少极值点个数，要求该点是rang1+range2内的最大值，需要尝试确定一下  
    range2 = 8  
    m = 0  # 峰值个数  
    T1 = np.arange(120)  
    for j in x:  
        if j <= range1:  
            a = j  
        else:  
            a = range1  
        if j + range2 >= 255:  
            b = 255 - j  
        else:  
            b = range2  
        z = y_01[j - a:j + b + 1]  
        if y_01[j] == np.max(z) and y_01[j] > y_01[j + 1] and y_01[j] > y_01[j - 1] and y_01[j] > num_sum / 1000:  
            if m >= 1 and abs(T1[m - 1] - j) > np.max([a, b]):  
                # 峰值条件：（1）极值（2）range1+range2内的最大值且只取一个（3）所占像素大于总像素的0.2%  
                T1[m] = j  
                m = m + 1  
            if m == 0:  
                T1[m] = j  
                m = m + 1  
        if j == 254:  
            break  
    T = T1[0:m]  
    T = T.flatten()  
    #print("峰值灰度:", T, "峰值个数:", m)  # 输出峰值数组  
  
    # 迭代  
    i = 0  
    L = 0  
    R = 255  
    ret = OTSU(img, L, R)  
    a1 = sum(x[0:ret+1] * y_01[0:ret+1]) / sum(y_01[0:ret+1])  
    a2 = sum(x[ret+1:256] * (y_01[ret+1:256])) / sum(y_01[ret+1:256])  
    a1 = int(a1)  
    a2 = int(a2)  
    times = np.arange(10)  # 规定一个最大迭代次数  
    for i in times:  
        a1 = sum(x[L:ret+1] * y_01[L:ret+1]) / sum(y_01[L:ret+1])  
        a2 = sum(x[ret+1:R] * (y_01[ret+1:R])) / sum(y_01[ret+1:R])  
        a1 = int(a1)  
        a2 = int(a2)  
        if i <= int(m / 2) and T[i] < a1:  
            L = T[i]  
        if i <= int(m / 2) and T[i] >= a1:  
            L = a1  
        if i <= int(m / 2) and T[m - i - 1] > a2:  
            R = T[m - i - 1]  
        if i <= int(m / 2) and T[m - i - 1] <= a2:  
            R = a2  
        ret0 = ret  
        ret = OTSU(img, L, R)  
        ret1 = ret  
        if abs(ret1 - ret0) < 2:  
            break  
    ret = ret0  
    rate = np.arange(256)  
    rate.dtype = np.float32  
    for i in np.arange(256):  
        rate[i] = y_01[i] / np.sum(y_01)  
    u1 = np.sum(rate[0:ret+1] * x[0:ret+1]) / np.sum(rate[0:ret+1])  
    u2 = np.sum(rate[ret+1:256] * x[ret+1:256]) / np.sum(rate[ret+1:256])  
    tl = int(0.726 * (u2 - u1))  
    th = int(4 * 0.726 * (u2 - u1))  
    return ret, tl, th, u2, u1, T  
def Titer_Maks(img, mask):  
    # python-otsu  
    def OTSU(img_gray, L, R):  
        img_gray = np.array(img_gray).ravel().astype(np.uint8)  # 变数组  
        ret = 0  
        PixSum = img_gray.size  # 总的像素数目=数组长度  
        PixCount = np.zeros(256)  # 各个灰度值的像素数目  
        PixRate = np.zeros(256)  # 各灰度值所占总像素数的比例  
        for i in range(PixSum):  # 统计各个灰度值的像素个数  
            # 默认灰度图像的像素值范围为GrayScale  
            Pixvalue = img_gray[i]  
            PixCount[Pixvalue] = PixCount[Pixvalue] + 1  
        for j in range(256):  
            PixRate[j] = PixCount[j] * 1.0 / PixSum  
        # 确定最大类间方差对应的阈值  
        Max_var = 0  
        for i in range(L, R):  # 从1开始是为了避免w1为0.  
            u1_tem = 0.0  
            u2_tem = 0.0  
            # 背景像素的比列  
            w1 = np.sum(PixRate[L:i]) / np.sum(PixRate[L:R])  
            # 前景像素的比例  
            w2 = np.sum(PixRate[i:R]) / np.sum(PixRate[L:R])  
            if w1 == 0 or w2 == 0:  
                pass  
            else:  # 背景像素的平均灰度值  
                for m in range(L, i):  
                    u1_tem = u1_tem + PixRate[m] * m  
                u1 = u1_tem * 1.0 / w1  
                # 前景像素的平均灰度值  
                for n in range(i, R):  
                    u2_tem = u2_tem + PixRate[n] * n  
                u2 = u2_tem / w2  
                # print(u1,u2)  
                # 类间方差公式：G=w1*w2*(u1-u2)**2  
                tem_var = w1 * w2 * np.power((u1 - u2), 2)  
                # print(tem_var)  
                # 判断当前类间方差是否为最大值。  
                if Max_var < tem_var:  
                    Max_var = tem_var  
                    ret = i  
        return ret  
    num_sum = img.size  
    hist = cv2.calcHist([img], [0], mask, [256], [0, 256])  # hist是256x1的数组，每个值对应于该图像中具有相应像素值的像素数  
    x = np.arange(256)  
    hist = hist.flatten()  # 列向量变数组  
    y = np.array(hist)  
    y = y.astype(int)  
  
    # 直方图滤波  
    y_01 = np.arange(256)  
    co_cal = [1 / 16, 1 / 16, 1 / 8, 1 / 4, 0, 1 / 4, 1 / 8, 1 / 16, 1 / 16]  
    for i in x:  
        if i <= 4:  
            la = i  
        else:  
            la = 4  
        if i + 4 >= 255:  
            rb = 255 - i  
        else:  
            rb = 4  
        y_01[i] = sum(co_cal[4 - la:4 + rb + 1] * y[i - la:i + rb + 1])  
        if i == 255:  
            break  
    y_01[0] = int(0.5*y[0]) + y_01[0]  
    y_01[255] = int(0.5 * y[255]) + y_01[255]  
    # plt.bar(x, y_01)  
    # plt.show()  
    # 寻找峰值  
    range1 = 8  # 为了减少极值点个数，要求该点是rang1+range2内的最大值，需要尝试确定一下  
    range2 = 8  
    m = 0  # 峰值个数  
    T1 = np.arange(120)  
    for j in x:  
        if j <= range1:  
            a = j  
        else:  
            a = range1  
        if j + range2 >= 255:  
            b = 255 - j  
        else:  
            b = range2  
        z = y_01[j - a:j + b + 1]  
        if y_01[j] == np.max(z) and y_01[j] > y_01[j + 1] and y_01[j] > y_01[j - 1] and y_01[j] > num_sum / 1000:  
            if m >= 1 and abs(T1[m - 1] - j) > np.max([a, b]):  
                # 峰值条件：（1）极值（2）range1+range2内的最大值且只取一个（3）所占像素大于总像素的0.2%  
                T1[m] = j  
                m = m + 1  
            if m == 0:  
                T1[m] = j  
                m = m + 1  
        if j == 254:  
            break  
    T = T1[0:m]  
    T = T.flatten()  
    #print("峰值灰度:", T, "峰值个数:", m)  # 输出峰值数组  
  
    # 迭代  
    i = 0  
    L = 0  
    R = 255  
    ret = OTSU(img, L, R)  
    if m != 0:  
        a1 = sum(x[0:ret + 1] * y_01[0:ret + 1]) / sum(y_01[0:ret + 1])  
        a2 = sum(x[ret + 1:256] * (y_01[ret + 1:256])) / sum(y_01[ret + 1:256])  
        times = np.arange(10)  # 规定一个最大迭代次数  
        for i in times:  
            a1 = sum(x[L:ret + 1] * y_01[L:ret + 1]) / sum(y_01[L:ret + 1])  
            a2 = sum(x[ret + 1:R] * (y_01[ret + 1:R])) / sum(y_01[ret + 1:R])  
            a1 = int(a1)  
            a2 = int(a2)  
            if i <= int(m / 2) and T[i] < a1:  
                L = T[i]  
            if i <= int(m / 2) and T[i] >= a1:  
                L = a1  
            if i <= int(m / 2) and T[m - i - 1] > a2:  
                R = T[m - i - 1]  
            if i <= int(m / 2) and T[m - i - 1] <= a2:  
                R = a2  
            ret0 = ret  
            ret = OTSU(img, L, R)  
            ret1 = ret  
            if abs(ret1 - ret0) < 2:  
                break  
        ret = ret0  
    rate = np.arange(256)  
    rate.dtype = np.float32  
    if np.sum(y_01) != 0:  
        for i in np.arange(256):  
            rate[i] = y_01[i] / np.sum(y_01)  
        if np.sum(rate[0:ret + 1]) == 0:  
            u1 = 0  
        else:  
            u1 = np.sum(rate[0:ret + 1] * x[0:ret + 1]) / np.sum(rate[0:ret + 1])  
        if np.sum(rate[ret + 1:256]) == 0:  
            u2 = 255  
        else:  
            u2 = np.sum(rate[ret + 1:256] * x[ret + 1:256]) / np.sum(rate[ret + 1:256])  
    else:  
        u1 = 0  
        u2 = 255  
    tl = int(0.726 * (u2 - u1))  
    th = int(4 * 0.726 * (u2 - u1))  
  
  
    return ret, tl, th, u2, u1, T  
def ConnectOpenLine(img):  
    y1, x1 = img.shape  
    img = cv2.morphologyEx(img, cv2.MORPH_CLOSE, np.ones((2, 2), np.uint8))  
    img = cv2.warpAffine(img, np.float32([[1, 0, -1], [0, 1, -1]]), (x1, y1))  
    return img  
def DivideCE(out_edge):  
    # 新函数，用于分开闭合轮廓与断裂线段  
    contours3, hierarchy3 = cv2.findContours(out_edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    edge_contour = np.zeros_like(out_edge)  
    edge_edge = np.zeros_like(out_edge)  
    M = np.float32([[1, 0, -1],  
                    [0, 1, -1]])  
    rows, cols = out_edge.shape  
    for c3 in contours3:  
        test_3 = np.zeros_like(out_edge)  
        edge_flood_1 = np.zeros_like(out_edge)  
        edge_flood_1 = cv2.drawContours(edge_flood_1, [c3], -1, [255], -1)  
        contour_flood = cv2.morphologyEx(edge_flood_1, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))  
        contour_flood = cv2.warpAffine(contour_flood, M, (cols, rows))  
        edge = cv2.subtract(edge_flood_1, contour_flood)  
        contour = cv2.subtract(edge_flood_1, edge)  
        contours_con, hierarchy_con = cv2.findContours(contour, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
        test_3 = cv2.drawContours(test_3, contours_con, -1, [255], 1)  
        edge_contour = cv2.add(edge_contour, test_3)  
        edge_edge = cv2.add(edge_edge, edge)  
    edge_edge = StandardizeEdge(edge_edge)  
    edge_edge = DeleteSmallEdge1(edge_edge)  
    return edge_contour, edge_edge  
def ContourArea(c):  
    # 新函数，用最小外接矩形的面积计算轮廓的面积，这样开线段的面积也可以计算了（骨骼化后的开线段面积为0）  
    rect = cv2.minAreaRect(c)  
    box = cv2.boxPoints(rect)  
    box = np.int0(box)  
    area = cv2.contourArea(box)  
    return area  
def DeleteSmallEdge0(img, min_len):  
    # 改动 （1）轮廓面积的计算改为使用ContourArea  
    minArea = 1  
    img_black = np.zeros_like(img)  
    real_contours = []  
    contours, hierarchy = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c in contours:  
        if len(c) > min_len:  
            real_contours.append(c)  
    img_black = cv2.drawContours(img_black, real_contours, -1, (255, 255, 255), 1)  
    return img_black  
def DeleteSmallEdge1(img):  
    # 改动 （1）轮廓面积的计算改为使用ContourArea  
    minArea = 1  
    img_black = np.zeros_like(img)  
    real_contours = []  
    contours, hierarchy = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c in contours:  
        area = ContourArea(c)  
        if area > minArea or len(c) > 4:  
            real_contours.append(c)  
    img_black = cv2.drawContours(img_black, real_contours, -1, (255, 255, 255), 1)  
  
    return img_black  
def ConnectClosePot(edge, broad_range, pix):  
    # 新函数，用于连接不在一条线上但只间隔一像素的点  
    frame_list = FramePotList(edge, broad_range, pix)  
    edge_pot_num, pot_list, edge = POI(edge)  
    for pot1 in pot_list:  
        for pot2 in pot_list:  
            if abs(pot1[0] - pot2[0]) <= 2 and abs(pot1[1] - pot2[1]) <= 2 and (pot1 == pot2).all() == False and ((pot2 == frame_list).all(1).any()) == False and ((pot1 == frame_list).all(1).any()) == False:  
                cv2.line(edge, (pot1[1], pot1[0]), (pot2[1], pot2[0]), (255, 255, 255), 1)  
    return edge  
def ConnectEdgepotOnSameContour(edge_edge, min_dis):  
    # 改动， abs(pot1[0] - pot2[0]) <= 4 and abs(pot1[1] - pot2[1]) <= 4设为4，放宽连接条件  
    contours5, hierarchy5 = cv2.findContours(edge_edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c5 in contours5:  
        test_20 = np.zeros_like(edge_edge)  
        test_20 = cv2.drawContours(test_20, [c5], -1, [255], 1)  
        edge_pot_num02, pot_list02, img02 = POI(test_20)  
        for pot1 in pot_list02:  
            for pot2 in pot_list02:  
                if abs(pot1[0] - pot2[0]) <= min_dis and abs(pot1[1] - pot2[1]) <= min_dis and (pot1 == pot2).all() == False:  
                    cv2.line(edge_edge, (pot1[1], pot1[0]), (pot2[1], pot2[0]), (255, 255, 255), 1)  
    return edge_edge  
def JudgeEdgePot(point, edge_broad):  
    poi_rot_1 = edge_broad[point[0] + 1 - 1:point[0] + 1 + 2, point[1] + 1 - 1:point[1] + 1 + 2]  
    poi_rot_2 = np.zeros_like(poi_rot_1)  
    poi_rot_2[1, 1] = poi_rot_1[1, 1]  
    poi_rot_2[0, 0] = poi_rot_1[1, 0]  
    poi_rot_2[0, 1] = poi_rot_1[0, 0]  
    poi_rot_2[0, 2] = poi_rot_1[0, 1]  
    poi_rot_2[1, 0] = poi_rot_1[2, 0]  
    poi_rot_2[1, 2] = poi_rot_1[0, 2]  
    poi_rot_2[2, 0] = poi_rot_1[2, 1]  
    poi_rot_2[2, 1] = poi_rot_1[2, 2]  
    poi_rot_2[2, 2] = poi_rot_1[1, 2]  
    poi_rot_judge = poi_rot_1 - poi_rot_2  
    if (len(np.argwhere(poi_rot_judge != 0))) != 2:  
        return False  
    else:  
        return True  
def POI(edge):  
    edge[edge == 255] = 1  
    edge = morphology.skeletonize(edge)  # 骨架提取  
    edge = edge.astype(np.uint8) * 255  
    # edge_poi = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    cnum = 0  
    edge_pot_list = []  
    cro_pot_list = []  
    for c in contours:  
        edge_pot_list1 = []  
        cro_pot_list1 = []  
        cnum = cnum + 1  
        test = np.zeros_like(img)  
        test = cv2.drawContours(test, [c], -1, [255], 1)  
        if cv2.contourArea(c) <= len(c):  # and cnum>11 and cnum<14  
            c_array = np.array(c).reshape(-1, 2)  
            c_array_mer = 10000 * c_array[:, 0] + c_array[:, 1]  
            c_count = np.bincount(c_array_mer)  
            poi_xy1 = np.where(c_count == 1)[0]  
            poi_xy2 = np.where(c_count >= 3)[0]  
            poi_xy = np.hstack((poi_xy1, poi_xy2))  
            x_poi = (poi_xy / 10000).astype('int32').reshape(-1, 1)  
            y_poi = (poi_xy - (poi_xy / 10000).astype('int32')*10000).astype('int32').reshape(-1, 1)  
            poi_list = list(np.hstack((y_poi, x_poi)))  
            edge_broad1 = cv2.copyMakeBorder(edge, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)  
            for poi in poi_list:  
                judge_poi = JudgeEdgePot(poi, edge_broad1)  
                if judge_poi == False:  
                    cro_pot_list.append(poi)  
                    cro_pot_list1.append(poi)  
                    # edge_poi[poi[0], poi[1]] = (0, 255, 0)  
                    # cv2.circle(edge_poi, (poi[1], poi[0]), 5, (0, 0, 255))                else:  
                    edge_pot_list.append(poi)  
                    edge_pot_list1.append(poi)  
                    # edge_poi[poi[0], poi[1]] = (0, 0, 255)  
                    # cv2.circle(edge_poi, (poi[1], poi[0]), 1, (0, 255, 0), -1)            # if len(edge_pot_list1) != 2:            #     if len(cro_pot_list1) == 0:            #         print(edge_pot_list1, cro_pot_list1)    return len(edge_pot_list), edge_pot_list, edge  
def Skeletonize(edge):  
    edge[edge == 255] = 1  
    edge = morphology.skeletonize(edge)  # 骨架提取  
    edge = edge.astype(np.uint8) * 255  
    return  edge  
def StandardizeEdge(openedge):  
    # 新函数，用于规范化输入的开线段，使之为规范的一像素开线段  
    bb = np.zeros_like(openedge)  
    contours, hierarchy = cv2.findContours(openedge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    bb = cv2.drawContours(bb, contours, -1, [255], -1)  
    bb[bb == 255] = 1  
    bb = morphology.skeletonize(bb)  # 骨架提取  
    bb = bb.astype(np.uint8) * 255  
    return bb  
def DeleteBifurcationLine(edge, broad_range, frame_dis_multiple):  
    def POI_for_Intersection(edge):  
        edge[edge == 255] = 1  
        edge = morphology.skeletonize(edge)  # 骨架提取  
        edge = edge.astype(np.uint8) * 255  
        # edge_poi = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)  
        contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
        cnum = 0  
        edge_pot_list = []  
        cro_pot_list = []  
        contour_list = []  
  
        for c in contours:  
            edge_pot_list1 = []  
            cro_pot_list1 = []  
            contour_list1 = []  
            cnum = cnum + 1  
            test = np.zeros_like(img)  
            test = cv2.drawContours(test, [c], -1, [255], 1)  
            if cv2.contourArea(c) <= len(c):  # and cnum>11 and cnum<14  
                c_array = np.array(c).reshape(-1, 2)  
                c_array_mer = 10000 * c_array[:, 0] + c_array[:, 1]  
                c_count = np.bincount(c_array_mer)  
                poi_xy1 = np.where(c_count == 1)[0]  
                poi_xy2 = np.where(c_count >= 3)[0]  
                poi_xy = np.hstack((poi_xy1, poi_xy2))  
                x_poi = (poi_xy / 10000).astype('int32').reshape(-1, 1)  
                y_poi = (poi_xy - (poi_xy / 10000).astype('int32') * 10000).astype('int32').reshape(-1, 1)  
                poi_list = list(np.hstack((y_poi, x_poi)))  
                edge_broad1 = cv2.copyMakeBorder(edge, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)  
                for poi in poi_list:  
                    judge_poi = JudgeEdgePot(poi, edge_broad1)  
                    if judge_poi == False:  
                        cro_pot_list1.append(poi)  
                        # edge_poi[poi[0], poi[1]] = (0, 255, 0)  
                        # cv2.circle(edge_poi, (poi[1], poi[0]), 5, (0, 0, 255))                    else:  
                        edge_pot_list1.append(poi)  
                        contour_list1.append(c)  
                        # edge_poi[poi[0], poi[1]] = (0, 0, 255)  
                        # cv2.circle(edge_poi, (poi[1], poi[0]), 1, (0, 255, 0), -1)                if len(edge_pot_list1) != 2:  
                    edge_pot_list = edge_pot_list + edge_pot_list1  
                    contour_list = contour_list + contour_list1  
        return len(edge_pot_list), edge_pot_list, edge, contour_list  
    frame_pot_list = FramePotList(edge, broad_range, 1)  
    while True:  
        edge_pot_num, edge_3pot_list, edge, contour_list = POI_for_Intersection(edge)  
        chain_list = []  
        intersection_list = []  
        for LineList_num in range(len(edge_3pot_list)):  
            chain, intersection = LineList(edge, contour_list[LineList_num], edge_3pot_list[LineList_num])  
            chain_list.append(chain)  
            intersection_list.append(intersection)  
        intersection_list_unique = list(np.unique(np.array(intersection_list), axis=0))  
        # print(intersection_list_unique)  
        # print(intersection_list)        for k_dbl1 in range(len(intersection_list_unique)):  
            chain_same_intersection = []  
            dis_chain_same_intersection = []  
  
            for k_dbl2 in range(len(intersection_list)):  
                dis_intersection = abs(intersection_list_unique[k_dbl1][0] - intersection_list[k_dbl2][0]) + abs(  
                    intersection_list_unique[k_dbl1][1] - intersection_list[k_dbl2][1])  
                # print(intersection_list_unique[k_dbl1], intersection_list[k_dbl2], dis_intersection)  
                if dis_intersection <= 2:  
                    chain_same_intersection.append(chain_list[k_dbl2])  
                    if (edge_3pot_list[k_dbl2] == frame_pot_list).all(1).any() == True:  
                        # print(edge_3pot_list[k_dbl2])  
                        dis_chain_same_intersection.append(frame_dis_multiple * len(chain_list[k_dbl2]))  
                    else:  
                        dis_chain_same_intersection.append(len(chain_list[k_dbl2]))  
            if len(chain_same_intersection) >= 2:  
                # 处理手段1：小比例距离去分叉  
                dis_judge_1 = min(dis_chain_same_intersection)  
                dis_chain_same_intersection1 = dis_chain_same_intersection.copy()  
                dis_chain_same_intersection1.remove(dis_judge_1)  
                dis_judge_2 = min(dis_chain_same_intersection1)  
  
                # edge_poi = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)  
                if dis_judge_1 / dis_judge_2 <= 1:  # (dis_judge_1/dis_judge_2 <= 1/5 and dis_judge_1 <= 5)  
                    chain_to_delete = chain_same_intersection[  
                        np.where(np.array(dis_chain_same_intersection) == dis_judge_1)[0][0]]  
                    for pot_to_delete in chain_to_delete:  
                        edge[pot_to_delete[0], pot_to_delete[1]] = 0  
                        # cv2.circle(edge_poi, (pot_to_delete[1], pot_to_delete[0]), 1, (255, 255, 0), -1)  
  
                # 处理手段2——梯度判断  
  
  
        edge_pot_num, edge_3pot_list, edge, contour_list = POI_for_Intersection(edge)  
        if edge_pot_num == 0:  
            break  
  
    return edge  
def POI_for_List(edge):  
    edge1 = edge.copy()  
    edge1[edge1 == 255] = 1  
    edge1 = morphology.skeletonize(edge1)  # 骨架提取  
    edge = edge1.astype(np.uint8) * 255  
  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    cnum = 0  
    edge_pot_list = []  
    contour_list = []  
    for c in contours:  
        cnum = cnum + 1  
        c_array = np.array(c).reshape(-1, 2)  
        c_yx = np.zeros_like(c_array)  
        c_yx[:, 0] = c_array[:, 0]  
        c_yx[:, 1] = c_array[:, 1]  
        contour_list.append(c_yx)  
        c_array_mer = 10000 * c_array[:, 0] + c_array[:, 1]  
        c_count = np.bincount(c_array_mer)  
        poi_xy1 = np.where(c_count == 1)[0]  
        poi_xy2 = np.where(c_count >= 3)[0]  
        poi_xy = np.hstack((poi_xy1, poi_xy2))  
        x_poi = (poi_xy / 10000).astype('int32').reshape(-1, 1)  
        y_poi = (poi_xy - (poi_xy / 10000).astype('int32') * 10000).astype('int32').reshape(-1, 1)  
        poi_list = list(np.hstack((y_poi, x_poi)))  
        edge_pot_list.append(poi_list)  
    return len(edge_pot_list), edge_pot_list, edge, contour_list, contours  
def Gra(img, tl_all, th_all):  
    gx1 = cv2.Sobel(img, cv2.CV_16S, 1, 0)  # 水平梯度  
    gy1 = cv2.Sobel(img, cv2.CV_16S, 0, 1)  # 竖直梯度  
    gx1_1 = gx1 / (255 * 4)  
    gx1_1 = gx1_1.astype('float32', copy=False)  
    gy1_1 = gy1 / (255 * 4)  
    gy1_1 = gy1_1.astype('float32', copy=False)  
    sqx = cv2.multiply(gx1_1, gx1_1, dst=None, scale=None, dtype=None)  
    sqy = cv2.multiply(gy1_1, gy1_1, dst=None, scale=None, dtype=None)  
    sumsq = cv2.add(sqx, sqy, dst=None, mask=None, dtype=None)  
    g1 = cv2.sqrt(sumsq, dst=None)  
    g1 = g1 * 1020  # 总梯度  
    # 归一化  
    g_img_ob = (g1/np.max(g1))*255  
    g_img_ob = g_img_ob.astype('uint8', copy=False)  
    tl_gra = int(tl_all / (np.max(g1) / 255))  
    th_gra = int(th_all / (np.max(g1) / 255))  
    return g_img_ob, tl_gra, th_gra,  
def OriEdge(img, broad_range, y_ori, x_ori):  
    img_blur1 = cv2.medianBlur(img, 3)  
    img_blur = cv2.GaussianBlur(img_blur1, (3, 3), 0, 0)  
    ret_all0, tl_all0, th_all0, u2_all0, u1_all0, T_all0 = Titer(img_blur1)  
    img_blur001 = cv2.copyMakeBorder(img_blur, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=255)  
    # 得到梯度图像  
    g_img, tl_gra, th_gra = Gra(img_blur, tl_all0, th_all0)  
    tl_gra, g_ret_low = cv2.threshold(g_img, tl_gra, 255, cv2.THRESH_BINARY)  
    th_gra, g_ret_high = cv2.threshold(g_img, th_gra-tl_gra, 255, cv2.THRESH_BINARY)  
    g_ret_low = g_ret_low[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori]  
    g_ret_low = cv2.copyMakeBorder(g_ret_low, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
    g_ret_high = g_ret_high[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori]  
    g_ret_high = cv2.copyMakeBorder(g_ret_high, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
    # 确定最初始的边缘  
    edge_all0 = cv2.Canny(img_blur001, tl_all0, th_all0 - tl_all0, apertureSize=3, L2gradient=True)[1:y_ori+2*broad_range-1, 1:x_ori+2*broad_range-1]  
    edge_all0 = Skeletonize(edge_all0)  
    edge_all0 = edge_all0[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori]  
    edge_all0 = cv2.copyMakeBorder(edge_all0, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
    # 迭代一次, 就是canny得到边缘膨胀后当作mask，和原图与了之后计算这一部分的各种阈值  
    titer_mask = cv2.morphologyEx(edge_all0, cv2.MORPH_DILATE, np.ones((15, 15), np.uint8))  
    ret_all1, tl_all1, th_all1, u2_all1, u1_all1, T_all1 = Titer_Maks(img_blur1, titer_mask)  
    # edge_all = cv2.Canny(img_blur, tl_all1, th_all0 - 1*tl_all0, apertureSize=3, L2gradient=True)# 保留之前的高阈值，高阈值小一点不丢轮廓  
    edge_all_high = cv2.Canny(img_blur, 2*tl_all1, th_all1 - tl_all1, apertureSize=3, L2gradient=True)  
    # edge_all = edge_all[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori]  
    # edge_all = cv2.copyMakeBorder(edge_all, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)    # edge_all = Skeletonize(edge_all)  
    # 规范化手段1——简单阈值分割（不能切割内部）（涉及膨胀了，kennel没法用）  
    thresh1, ret_all = cv2.threshold(img, ret_all1, 255, cv2.THRESH_BINARY)  # 利用阈值开始去掉切割内部的线，但由于膨胀了，可能不适合密集的图像  
    edge_all_high_dia = cv2.morphologyEx(edge_all_high, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
    ret_all = cv2.subtract(ret_all, edge_all_high_dia)  
    ret_all = cv2.subtract(ret_all, g_ret_high)  
    ret_all_dia = cv2.morphologyEx(ret_all, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))  
    # ret_all_dia = cv2.morphologyEx(ret_all_dia, cv2.MORPH_ERODE, np.ones((3, 3), np.uint8))  
    edge_all = edge_all0  
    return edge_all, g_img, g_ret_low, g_ret_high, ret_all_dia, img_blur  
def DeleteLowGraEdge(edge, g_ret_high):  
    img_black = np.zeros_like(edge)  
    real_contours = []  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c in contours:  
        img_black0 = np.zeros_like(edge)  
        cv2.drawContours(img_black0, [c], -1, (255, 255, 255), 1)  
        high_g_judge = cv2.bitwise_and(img_black0, g_ret_high)  
        if cv2.countNonZero(high_g_judge) != 0:  
            real_contours.append(c)  
    img_black = cv2.drawContours(img_black, real_contours, -1, (255, 255, 255), 1)  
    return img_black  
def FramePotList(edge, broad_range, pix):  
    y001, x001 = edge.shape  
    frame_img = np.zeros_like(edge)[broad_range+pix:y001-broad_range-pix, broad_range+pix:x001-broad_range-pix]  
    frame_img = cv2.copyMakeBorder(frame_img, pix, pix, pix, pix, cv2.BORDER_CONSTANT, value=255)  
    frame_img = cv2.copyMakeBorder(frame_img, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
    frame_list = np.argwhere(frame_img)  
    return frame_list  
def FrameEdge(edge, broad_range, pix):  
    img_black = np.zeros_like(edge)  
    img_black1 = np.zeros_like(edge)  
    img_black2 = np.zeros_like(edge)  
    frame_list_add = FramePotList(edge, broad_range, pix)  
    pix = 1  
    frame_list = FramePotList(edge, broad_range, pix)  
    frame_contour = []  
    not_frame_contour = []  
    not_frame_contour_add = []  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c in contours:  
        img_black0 = np.zeros_like(edge)  
        cv2.drawContours(img_black0, [c], -1, (255, 255, 255), 1)  
        edge_pot_num001, edge_point_list001, img_black0 = POI(img_black0)  
        if edge_pot_num001 == 2:  
            if ((edge_point_list001[0] == frame_list).all(1).any()) == True and ((edge_point_list001[1] == frame_list).all(1).any()) == True:  
                frame_contour.append(c)  
            elif ((edge_point_list001[0] == frame_list_add).all(1).any()) == True and ((edge_point_list001[1] == frame_list_add).all(1).any()) == True:  
                not_frame_contour_add.append(c)  
            else:  
                not_frame_contour.append(c)  
        else:  
            not_frame_contour.append(c)  
    img_black = cv2.drawContours(img_black, frame_contour, -1, (255, 255, 255), 1)  
    img_black1 = cv2.drawContours(img_black1, not_frame_contour, -1, (255, 255, 255), 1)  
    img_black2 = cv2.drawContours(img_black2, not_frame_contour_add, -1, (255, 255, 255), 1)  
    return img_black, img_black1, img_black2  
def WaterEdge(edge, img, imgin, area_all, open_edge_num, initial_median_col, max_median_col, ksize):  
    def Water(sure_fg, unknown, imgin, edge_out, area_all, img, u_water_all, initial_median_col, max_median_col):  
        # Marker labelling  
        ret, markers = cv2.connectedComponents(sure_fg)  
        # Add one to all labels so that sure background is not 0, but 1  
        markers = markers + 1  
        # Now, mark the region of unknown with zero  
        markers[unknown == 255] = 0  
  
        markers_copy = markers.copy()  
        markers_0 = markers.copy()  
        markers_copy[markers == 0] = 150  # 灰色表示背景  
        markers_copy[markers == 1] = 0  # 黑色表示背景  
        markers_copy[markers > 1] = 255  # 白色表示前景  
        markers_copy = np.uint8(markers_copy)  
        imgin1 = cv2.medianBlur(imgin, initial_median_col)  
        # 使用分水岭算法执行基于标记的图像分割，将图像中的对象与背景分离  
        markers = cv2.watershed(imgin1, markers)  
  
        water_line = np.zeros_like(unknown)  
        water_sbg = np.zeros_like(unknown)  
        img_show = imgin.copy()  
        water_line[markers == -1] = [255]  
        water_sbg[markers == 1] = [255]  
        edge_out[markers == -1] = [255]  
        img_show[markers == 1] = [0, 255, 0]  
        # cv2.imshow(str(num0) + 'markers_copy.jpg', markers_copy)  
        # cv2.imshow(str(num0) + 'img_show.jpg', img_show)        # # cv2.imshow(str(num0) + 'edge.jpg', edge)        # cv2.waitKey(0)        # cv2.destroyAllWindows()        # img_show[markers == 1] = [0, 255, 0]        return water_line, water_sbg  
    def Unknown3(test1, img, ksize):  
        judge = 1  
        def Outin(edge, ksize):  
            test1_close_7 = cv2.morphologyEx(edge, cv2.MORPH_CLOSE, np.ones((7, 7), np.uint8))  
            contours111, hierarchy111 = cv2.findContours(test1_close_7, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
            if len(contours111) != 1:  
                ksize = 3  
                # print('间距较小的边缘')  
            if ksize == 3:  
                dia_times = 1  
                judge1 = 4  
            else:  
                dia_times = 2  
                judge1 = 8  
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (ksize, ksize))  
  
            while True:  
                close_judge = 0  
                num, edge_pot_list, edge, contour_list, contours_ori = POI_for_List(edge)  
                pot_dia = np.zeros_like(edge)  
                for pot_num in range(len(edge_pot_list[0])):  
                    test = np.zeros_like(edge)  
                    test[edge_pot_list[0][pot_num][0], edge_pot_list[0][pot_num][1]] = 255  
                    pot_dia0 = cv2.dilate(test, kernel, iterations=dia_times)  
                    pot_dia = cv2.add(pot_dia, pot_dia0)  
                    pot_dia1 = cv2.dilate(test, kernel, iterations=2)  
                    judge_in = cv2.bitwise_and(edge, pot_dia1)  
                    a1 = np.argwhere(judge_in == 255)  
                    num1 = np.where(  
                        (contour_list[0] == np.array([edge_pot_list[0][pot_num][1], edge_pot_list[0][pot_num][0]])).all(  
                            1) == True)  
                    for pot in a1:  
                        pot = np.array([pot[1], pot[0]])  
                        num_list = np.where((contour_list[0] == pot).all(1) == True)[0]  
                        if len(num_list) == 2:  
                            if abs((num_list[0] + num_list[0]) / 2 - num1) > judge1:  
                                edge[edge_pot_list[0][pot_num][0], edge_pot_list[0][pot_num][1]] = 0  
                                close_judge = 1  
                if close_judge == 0:  
                    break  
            edge_dia = cv2.dilate(edge, kernel, iterations=1)  
            kernelx = np.array([[1, 0], [0, 1]], dtype=int)  
            kernely = np.array([[0, 1], [1, 0]], dtype=int)  
            y, x = edge.shape  
            gx = cv2.filter2D(edge, cv2.CV_16S, kernelx)  
            gy = cv2.filter2D(edge, cv2.CV_16S, kernely)  
            gx1 = gx.copy()  
            gy1 = gy.copy()  
            gx1[gx == 510] = 255  
            gx1[gx != 510] = 0  
            gy1[gy == 510] = 255  
            gy1[gy != 510] = 0  
  
            gx1 = gx1.astype('uint8')  
            gy1 = gy1.astype('uint8')  
            gx1 = cv2.bitwise_and(gx1, edge)  
            gy1 = cv2.warpAffine(gy1, np.float32([[1, 0, 0], [0, 1, -1]]), (x, y))  
            gy1 = cv2.bitwise_and(gy1, edge)  
  
            x1 = cv2.warpAffine(gx1, np.float32([[1, 0, -1], [0, 1, 0]]), (x, y))  
            x2 = cv2.warpAffine(gx1, np.float32([[1, 0, 0], [0, 1, -1]]), (x, y))  
            x_sub = cv2.add(x1, x2)  
            y1 = cv2.warpAffine(gy1, np.float32([[1, 0, -1], [0, 1, 0]]), (x, y))  
            y2 = cv2.warpAffine(gy1, np.float32([[1, 0, 0], [0, 1, 1]]), (x, y))  
            y_sub = cv2.add(y1, y2)  
            xy = cv2.add(x_sub, y_sub)  
            ll = cv2.subtract(edge_dia, xy)  
            ll = cv2.subtract(ll, edge)  
            outin = cv2.subtract(ll, pot_dia)  
  
            if ksize == 5:  
                y1, x1 = edge.shape  
                outin = cv2.morphologyEx(outin, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))  
                outin = cv2.warpAffine(outin, np.float32([[1, 0, -1], [0, 1, -1]]), (x1, y1))  
                # outin = cv2.morphologyEx(outin, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))  
                # outin = cv2.warpAffine(outin, np.float32([[1, 0, -1], [0, 1, -1]]), (x1, y1))  
            return outin  
        img_black6 = np.zeros_like(img)  
        inner_contour = np.zeros_like(img)  
        outer_contour = np.zeros_like(img)  
        sbg = np.zeros_like(img)  
        sfg = np.zeros_like(img)  
        outin = Outin(test1, ksize)  
        contours, hierarchy = cv2.findContours(outin, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
        img_black6 = cv2.drawContours(img_black6, contours, -1, (255, 255, 255), -1)  
        contours1, hierarchy1 = cv2.findContours(img_black6, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
        if len(contours1) <= 1:  
            if ksize != 3:  
                ksize = 3  
                outin = Outin(test1, ksize)  
                img_black6 = np.zeros_like(img)  
                contours, hierarchy = cv2.findContours(outin, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                img_black6 = cv2.drawContours(img_black6, contours, -1, (255, 255, 255), 1)  
                contours1, hierarchy1 = cv2.findContours(img_black6, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                if len(contours1) <= 1:  
                    judge = 0  
                    # print('图' + str(num0) + '无法产生最近邻的两条独立线段')  
        if len(contours1) >= 2:  
            inner_contour = cv2.drawContours(inner_contour, contours1[0], -1, [255], 1)  
            outer_contour = cv2.drawContours(outer_contour, contours1[1], -1, [255], 1)  
            judge_inner_contour = cv2.bitwise_and(inner_contour, img)  
            judge_outer_contour = cv2.bitwise_and(outer_contour, img)  
            judge_k1 = np.sum(judge_inner_contour) / cv2.countNonZero(judge_inner_contour)  
            judge_k2 = np.sum(judge_outer_contour) / cv2.countNonZero(judge_outer_contour)  
            if judge_k1 < judge_k2:  
                sbg = inner_contour  
                sfg = outer_contour  
            else:  
                sbg = outer_contour  
                sfg = inner_contour  
        unknow = np.zeros_like(img)  
        unknow = cv2.subtract(cv2.bitwise_not(unknow), sfg)  
        unknow = cv2.subtract(unknow, sbg)  
        return sfg, sbg, unknow, judge  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    edge_out = np.zeros_like(edge)  
    sfg_all = np.zeros_like(edge)  
    sbg_all = np.zeros_like(edge)  
    close_open_edge = np.zeros_like(edge)  
    u_water_all = np.sum(img) / cv2.countNonZero(img)  
    for c in contours:  
        open_edge_num = open_edge_num + 1  
        test1 = np.zeros_like(edge)  
        test1 = cv2.drawContours(test1, [c], -1, [255], 1)  
        if len(c) < 28:  
            sfg, sbg, unknown, water_judge = Unknown3(test1, img, 3)  
            if water_judge == 0:  
                close_open_edge = cv2.add(close_open_edge, test1)  
        else:  
            sfg, sbg, unknown, water_judge = Unknown3(test1, img, ksize)  
  
            if water_judge == 0:  
                close_open_edge = cv2.add(close_open_edge, test1)  
        sfg_all =cv2.add(sfg_all, sfg)  
        sbg_all =cv2.add(sbg_all, sbg)  
    unknown_all = cv2.add(sfg_all, sbg_all)  
    unknown_all = cv2.bitwise_not(unknown_all)  
    water_line, water_sbb = Water(sfg_all, unknown_all, imgin, edge_out, area_all, img, u_water_all, initial_median_col, max_median_col)  
    close_open_edge = cv2.morphologyEx(close_open_edge, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))  
    close_open_edge, edge_judge_0 = DivideCE(close_open_edge)  
    contour_wide_open = np.zeros_like(edge)  
    contours00, hierarchy00 = cv2.findContours(close_open_edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    water_sbb = cv2.bitwise_not(water_sbb)  
    contours, hierarchy = cv2.findContours(water_sbb, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    cv2.drawContours(contour_wide_open, contours, -1, [255, 255, 255], 1)  
    cv2.drawContours(contour_wide_open, contours00, -1, [255, 255, 255], 1)  
    return contour_wide_open  
def LineList(edge, c_incld_pot, pot):  
    edge_broad_line = cv2.copyMakeBorder(edge, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)  
    chain = []  
    pot_serial_num = np.where((c_incld_pot == [pot[1], pot[0]]).all(1).all(1) == True)[0][0]  
  
    incre = 1  
    while True:  
        pot_serial = np.array([c_incld_pot[pot_serial_num][0][1], c_incld_pot[pot_serial_num][0][0]])  
        if JudgeEdgePot(pot_serial, edge_broad_line) == True:  
            # print(pot_serial_num, c_incld_pot[pot_serial_num])  
            edge_broad_line[pot_serial[0] + 1, pot_serial[1] + 1] = 0  
            chain.append(pot_serial)  
        else:  
            # print(pot_serial_num, c_incld_pot[pot_serial_num])  
            intersection = pot_serial  
            break  
        pot_serial_num = pot_serial_num + incre  
        if pot_serial_num == len(c_incld_pot):  
            pot_serial_num = 0  
    edge_broad_line = cv2.copyMakeBorder(edge, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)  
    intersection1 = intersection  
    chain1 = chain  
    chain = []  
    pot_serial_num = np.where((c_incld_pot == [pot[1], pot[0]]).all(1).all(1) == True)[0][0]  
    incre = -1  
    while True:  
        pot_serial = np.array([c_incld_pot[pot_serial_num][0][1], c_incld_pot[pot_serial_num][0][0]])  
        if JudgeEdgePot(pot_serial, edge_broad_line) == True:  
            # print(pot_serial_num, c_incld_pot[pot_serial_num])  
            edge_broad_line[pot_serial[0] + 1, pot_serial[1] + 1] = 0  
            chain.append(pot_serial)  
        else:  
            # print(pot_serial_num, c_incld_pot[pot_serial_num])  
            intersection = pot_serial  
            break  
        pot_serial_num = pot_serial_num + incre  
    if len(chain1) <= len(chain):  
        chain = chain1  
        intersection = intersection1  
    # edge_poi = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)  
    # for pot in chain:    #     cv2.circle(edge_poi, (pot[1], pot[0]), 1, (255, 255, 0), -1)    # cv2.imshow('edge_poi.jpg', edge_poi)    # cv2.waitKey(0)    # cv2.destroyAllWindows()    return chain, intersection  
def WaterEdge1(edge, img, imgin, col, ksize):  
    def Water(sure_fg, unknown, imgin, edge_out, col):  
        # Marker labelling  
        ret, markers = cv2.connectedComponents(sure_fg)  
        # Add one to all labels so that sure background is not 0, but 1  
        markers = markers + 1  
        # Now, mark the region of unknown with zero  
        markers[unknown == 255] = 0  
  
        markers_copy = markers.copy()  
        markers_0 = markers.copy()  
        markers_copy[markers == 0] = 150  # 灰色表示背景  
        markers_copy[markers == 1] = 0  # 黑色表示背景  
        markers_copy[markers > 1] = 255  # 白色表示前景  
        markers_copy = np.uint8(markers_copy)  
        imgin1 = cv2.medianBlur(imgin, col)  
        # 使用分水岭算法执行基于标记的图像分割，将图像中的对象与背景分离  
        markers = cv2.watershed(imgin1, markers)  
  
        water_line = np.zeros_like(unknown)  
        water_sbg = np.zeros_like(unknown)  
        img_show = imgin1.copy()  
        water_line[markers == -1] = [255]  
        water_sbg[markers == 1] = [255]  
        edge_out[markers == -1] = [255]  
        img_show[markers == 2] = [0, 255, 0]  
        # img_show[markers == 1] = [0, 255, 0]  
        return water_line, water_sbg  
    def Unknown3(test1, img, ksize):  
        judge = 1  
        def Outin(edge, ksize):  
            test1_close_7 = cv2.morphologyEx(edge, cv2.MORPH_CLOSE, np.ones((7, 7), np.uint8))  
            contours111, hierarchy111 = cv2.findContours(test1_close_7, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
            if len(contours111) != 1:  
                ksize = 3  
                # print('间距较小的边缘')  
            if ksize == 3:  
                dia_times = 1  
                judge1 = 4  
            else:  
                dia_times = 2  
                judge1 = 8  
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (ksize, ksize))  
  
            while True:  
                close_judge = 0  
                num, edge_pot_list, edge, contour_list, contours_ori = POI_for_List(edge)  
                pot_dia = np.zeros_like(edge)  
                for pot_num in range(len(edge_pot_list[0])):  
                    test = np.zeros_like(edge)  
                    test[edge_pot_list[0][pot_num][0], edge_pot_list[0][pot_num][1]] = 255  
                    pot_dia0 = cv2.dilate(test, kernel, iterations=dia_times)  
                    pot_dia = cv2.add(pot_dia, pot_dia0)  
                    pot_dia1 = cv2.dilate(test, kernel, iterations=2)  
                    judge_in = cv2.bitwise_and(edge, pot_dia1)  
                    a1 = np.argwhere(judge_in == 255)  
                    num1 = np.where(  
                        (contour_list[0] == np.array([edge_pot_list[0][pot_num][1], edge_pot_list[0][pot_num][0]])).all(  
                            1) == True)  
                    for pot in a1:  
                        pot = np.array([pot[1], pot[0]])  
                        num_list = np.where((contour_list[0] == pot).all(1) == True)[0]  
                        if len(num_list) == 2:  
                            if abs((num_list[0] + num_list[0]) / 2 - num1) > judge1:  
                                edge[edge_pot_list[0][pot_num][0], edge_pot_list[0][pot_num][1]] = 0  
                                close_judge = 1  
                if close_judge == 0:  
                    break  
            edge_dia = cv2.dilate(edge, kernel, iterations=1)  
            kernelx = np.array([[1, 0], [0, 1]], dtype=int)  
            kernely = np.array([[0, 1], [1, 0]], dtype=int)  
            y, x = edge.shape  
            gx = cv2.filter2D(edge, cv2.CV_16S, kernelx)  
            gy = cv2.filter2D(edge, cv2.CV_16S, kernely)  
            gx1 = gx.copy()  
            gy1 = gy.copy()  
            gx1[gx == 510] = 255  
            gx1[gx != 510] = 0  
            gy1[gy == 510] = 255  
            gy1[gy != 510] = 0  
  
            gx1 = gx1.astype('uint8')  
            gy1 = gy1.astype('uint8')  
            gx1 = cv2.bitwise_and(gx1, edge)  
            gy1 = cv2.warpAffine(gy1, np.float32([[1, 0, 0], [0, 1, -1]]), (x, y))  
            gy1 = cv2.bitwise_and(gy1, edge)  
  
            x1 = cv2.warpAffine(gx1, np.float32([[1, 0, -1], [0, 1, 0]]), (x, y))  
            x2 = cv2.warpAffine(gx1, np.float32([[1, 0, 0], [0, 1, -1]]), (x, y))  
            x_sub = cv2.add(x1, x2)  
            y1 = cv2.warpAffine(gy1, np.float32([[1, 0, -1], [0, 1, 0]]), (x, y))  
            y2 = cv2.warpAffine(gy1, np.float32([[1, 0, 0], [0, 1, 1]]), (x, y))  
            y_sub = cv2.add(y1, y2)  
            xy = cv2.add(x_sub, y_sub)  
            ll = cv2.subtract(edge_dia, xy)  
            ll = cv2.subtract(ll, edge)  
            outin = cv2.subtract(ll, pot_dia)  
  
            if ksize == 5:  
                y1, x1 = edge.shape  
                outin = cv2.morphologyEx(outin, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))  
                outin = cv2.warpAffine(outin, np.float32([[1, 0, -1], [0, 1, -1]]), (x1, y1))  
                # outin = cv2.morphologyEx(outin, cv2.MORPH_OPEN, np.ones((2, 2), np.uint8))  
                # outin = cv2.warpAffine(outin, np.float32([[1, 0, -1], [0, 1, -1]]), (x1, y1))  
            return outin  
        img_black6 = np.zeros_like(img)  
        inner_contour = np.zeros_like(img)  
        outer_contour = np.zeros_like(img)  
        sbg = np.zeros_like(img)  
        sfg = np.zeros_like(img)  
        outin = Outin(test1, ksize)  
        contours, hierarchy = cv2.findContours(outin, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
        img_black6 = cv2.drawContours(img_black6, contours, -1, (255, 255, 255), -1)  
        contours1, hierarchy1 = cv2.findContours(img_black6, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
        if len(contours1) <= 1:  
            if ksize != 3:  
                ksize = 3  
                outin = Outin(test1, ksize)  
                img_black6 = np.zeros_like(img)  
                contours, hierarchy = cv2.findContours(outin, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                img_black6 = cv2.drawContours(img_black6, contours, -1, (255, 255, 255), 1)  
                contours1, hierarchy1 = cv2.findContours(img_black6, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                if len(contours1) <= 1:  
                    judge = 0  
                    # print('图' + str(num0) + '无法产生最近邻的两条独立线段')  
        if len(contours1) >= 2:  
            inner_contour = cv2.drawContours(inner_contour, contours1[0], -1, [255], 1)  
            outer_contour = cv2.drawContours(outer_contour, contours1[1], -1, [255], 1)  
            judge_inner_contour = cv2.bitwise_and(inner_contour, img)  
            judge_outer_contour = cv2.bitwise_and(outer_contour, img)  
            judge_k1 = np.sum(judge_inner_contour) / cv2.countNonZero(judge_inner_contour)  
            judge_k2 = np.sum(judge_outer_contour) / cv2.countNonZero(judge_outer_contour)  
            if judge_k1 < judge_k2:  
                sbg = inner_contour  
                sfg = outer_contour  
            else:  
                sbg = outer_contour  
                sfg = inner_contour  
        unknow = np.zeros_like(img)  
        unknow = cv2.subtract(cv2.bitwise_not(unknow), sfg)  
        unknow = cv2.subtract(unknow, sbg)  
        return sfg, sbg, unknow, judge  
    contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    edge_out = np.zeros_like(edge)  
    sfg_all = np.zeros_like(edge)  
    sbg_all = np.zeros_like(edge)  
    for c in contours:  
        test1 = np.zeros_like(edge)  
        test1 = cv2.drawContours(test1, [c], -1, [255], 1)  
        if len(c) < 28:  
            sfg, sbg, unknown, water_judge = Unknown3(test1, img, 3)  
        else:  
            sfg, sbg, unknown, water_judge = Unknown3(test1, img, ksize)  
        sfg_all =cv2.add(sfg_all, sfg)  
        sbg_all =cv2.add(sbg_all, sbg)  
    unknown_all = cv2.add(sfg_all, sbg_all)  
    unknown_all = cv2.bitwise_not(unknown_all)  
    water_line, water_sbb = Water(sfg_all, unknown_all, imgin, edge_out, col)  
    contour_wide_open = np.zeros_like(edge)  
    contours, hierarchy = cv2.findContours(water_sbb, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    cv2.drawContours(contour_wide_open, contours, -1, [255, 255, 255], 1)  
    return contour_wide_open  
def GraJudge(c_cor, test_cor, gy, gx, g_bro):  
    p_num = 0  
    n_num = 0  
    g_list = []  
    pot_list_g = []  
    chain = []  
    if len(c_cor) <= cv2.contourArea(c_cor):  
        for pot_num in range(len(c_cor) - 1):  
            y1 = c_cor[pot_num + 1][0][1] - c_cor[pot_num][0][1]  
            x1 = c_cor[pot_num + 1][0][0] - c_cor[pot_num][0][0]  
            y2 = gy[c_cor[pot_num][0][1] + g_bro, c_cor[pot_num][0][0] + g_bro]  
            x2 = gx[c_cor[pot_num][0][1] + g_bro, c_cor[pot_num][0][0] + g_bro]  
            gra0 = (x1 * y2 - x2 * y1)  
            g_list.append(gra0)  
            if gra0 >= 0:  
                p_num = p_num + 1  
            else:  
                n_num = n_num + 1  
    else:  
        pot_num, edge_pot_list, test_cor, contour_list, contours_ori = POI_for_List(test_cor)  
        if len(edge_pot_list[0]) != 2:  
            test_cor = cv2.morphologyEx(test_cor, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))  
            test_cor = Skeletonize(test_cor)  
            test_cor = DeleteBifurcationLine(test_cor, broad_range, frame_dis_multiple=10)  
            pot_num, edge_pot_list, test_cor, contour_list, contours_ori = POI_for_List(test_cor)  
        if len(edge_pot_list[0]) == 2:  
            chain, intersection = LineList(test_cor, contours_ori[0], edge_pot_list[0][0])  
            for pot_num in range(len(chain) - 1):  
                y1 = chain[pot_num + 1][0] - chain[pot_num][0]  
                x1 = chain[pot_num + 1][1] - chain[pot_num][1]  
                y2 = gy[chain[pot_num][0] + g_bro, chain[pot_num][1] + g_bro]  
                x2 = gx[chain[pot_num][0] + g_bro, chain[pot_num][1] + g_bro]  
                gra0 = (x1 * y2 - x2 * y1)  
                g_list.append(gra0)  
                if gra0 >= 0:  
                    p_num = p_num + 1  
                else:  
                    n_num = n_num + 1  
            pot_list_g.append(chain[0])  
            pot_list_g.append(chain[len(chain) - 1])  
    if (p_num + n_num) == 0:  
        pn_np = 0  
    else:  
        pn_np = abs((p_num - n_num) / (p_num + n_num))  
    return pn_np, g_list, pot_list_g, chain  
def POStoFrame(pot, y_ori, x_ori):  
    if (abs(pot[0]-0) > 0 and abs(pot[0]-0) < 3) and (abs(pot[1]-0) > 0 and abs(pot[1]-0)):  
        if abs(pot[0]-0) <= abs(pot[1]-0):  
            pot[0] = 0  
        else:  
            pot[1] = 0  
    elif (abs(pot[0]-0) > 0 and abs(pot[0]-0) < 3) and (abs(pot[1]-x_ori+1) > 0 and abs(pot[1]-x_ori+1) < 3):  
        if abs(pot[0]-0) <= abs(pot[1]-x_ori+1):  
            pot[0] = 0  
        else:  
            pot[1] = x_ori-1  
    elif (abs(pot[0]-y_ori+1) > 0 and abs(pot[0]-y_ori+1) < 3)  and (abs(pot[1]-0) > 0 and abs(pot[1]-0)):  
        if abs(pot[0]-y_ori+1) <= abs(pot[1]-0):  
            pot[0] = y_ori-1  
        else:  
            pot[1] = 0  
    elif (abs(pot[0]-y_ori+1) > 0 and abs(pot[0]-y_ori+1) < 3) and (abs(pot[1]-x_ori+1) > 0 and abs(pot[1]-x_ori+1) < 3):  
        if abs(pot[0]-y_ori+1) <= abs(pot[1]-x_ori+1):  
            pot[0] = y_ori-1  
        else:  
            pot[1] = x_ori-1  
    elif abs(pot[0]-0) > 0 and abs(pot[0]-0) < 3:  
        pot[0] = 0  
    elif abs(pot[1]-0) > 0 and abs(pot[1]-0) < 3:  
        pot[1] = 0  
    elif abs(pot[0]-y_ori+1) > 0 and abs(pot[0]-y_ori+1) < 3:  
        pot[0] = y_ori-1  
    elif abs(pot[1]-x_ori+1) > 0 and abs(pot[1]-x_ori+1) < 3:  
        pot[1] = x_ori-1  
    return pot  
def POStoNUM(pot, y_ori, x_ori):  
    num = 2*(y_ori+x_ori)  
    if abs(pot[1]-0) == 0:  
        num = pot[0]  
    if abs(pot[0] - y_ori + 1) == 0:  
        num = y_ori-1+pot[1]  
    if abs(pot[1] - x_ori + 1) == 0:  
        num = y_ori-1+x_ori-1 + y_ori-1-pot[0]  
    if abs(pot[0] - 0) == 0 and abs(pot[1]-0) != 0:  
        num = y_ori-1+x_ori-1 + y_ori-1+x_ori-1-pot[1]  
    return num  
def FramePotAllList(y_ori, x_ori):  
    frame_pot_all_list = []  
    for i in range(y_ori):  
        frame_pot_all_list.append(np.array([i, 0]))  
    for j in range(1, x_ori):  
        frame_pot_all_list.append(np.array([y_ori-1, j]))  
    for i in range(y_ori-1):  
        frame_pot_all_list.append(np.array([y_ori-1-(i+1), x_ori-1]))  
    for j in range(y_ori-2):  
        frame_pot_all_list.append(np.array([0, x_ori-1-(j+1)]))  
    return frame_pot_all_list  
def MaskforChoice(test_e, num0, num1, frame_pot_all_list):  
    mask_for_choice = np.zeros_like(test_e)  
    for pot in frame_pot_all_list[num0:num1]:  
        mask_for_choice[pot[0], pot[1]] = 255  
    mask_for_choice = cv2.add(mask_for_choice, test_e)  
    mask_for_choice = ConnectEdgepotOnSameContour(mask_for_choice, 6)  
    contours_mask, hierarchy_mask = cv2.findContours(mask_for_choice, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    cv2.drawContours(mask_for_choice, contours_mask, -1, [255, 255, 255], -1)  
    return mask_for_choice  
def Maks_min(mask_min):  
    mask_min = cv2.add(ConnectClosePot(mask_min, 0, 0), mask_min)  
    contours_mask, hierarchy_mask = cv2.findContours(mask_min, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    cv2.drawContours(mask_min, contours_mask, -1, [255, 255, 255], -1)  
    return mask_min  
def DeleteBifurcationLineG(edge, g_sobel_all, broad_range, gy, gx, g_bro,frame_dis_multiple, method):  
    def POI_for_Intersection(edge):  
        edge[edge == 255] = 1  
        edge = morphology.skeletonize(edge)  # 骨架提取  
        edge = edge.astype(np.uint8) * 255  
        # edge_poi = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)  
        contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
        cnum = 0  
        edge_pot_list = []  
        cro_pot_list = []  
        contour_list = []  
  
        for c in contours:  
            edge_pot_list1 = []  
            cro_pot_list1 = []  
            contour_list1 = []  
            cnum = cnum + 1  
            test = np.zeros_like(img)  
            test = cv2.drawContours(test, [c], -1, [255], 1)  
            if cv2.contourArea(c) <= len(c):  # and cnum>11 and cnum<14  
                c_array = np.array(c).reshape(-1, 2)  
                c_array_mer = 10000 * c_array[:, 0] + c_array[:, 1]  
                c_count = np.bincount(c_array_mer)  
                poi_xy1 = np.where(c_count == 1)[0]  
                poi_xy2 = np.where(c_count >= 3)[0]  
                poi_xy = np.hstack((poi_xy1, poi_xy2))  
                x_poi = (poi_xy / 10000).astype('int32').reshape(-1, 1)  
                y_poi = (poi_xy - (poi_xy / 10000).astype('int32') * 10000).astype('int32').reshape(-1, 1)  
                poi_list = list(np.hstack((y_poi, x_poi)))  
                edge_broad1 = cv2.copyMakeBorder(edge, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)  
                for poi in poi_list:  
                    judge_poi = JudgeEdgePot(poi, edge_broad1)  
                    if judge_poi == False:  
                        cro_pot_list1.append(poi)  
                        # edge_poi[poi[0], poi[1]] = (0, 255, 0)  
                        # cv2.circle(edge_poi, (poi[1], poi[0]), 5, (0, 0, 255))                    else:  
                        edge_pot_list1.append(poi)  
                        contour_list1.append(c)  
                        # edge_poi[poi[0], poi[1]] = (0, 0, 255)  
                        # cv2.circle(edge_poi, (poi[1], poi[0]), 1, (0, 255, 0), -1)                if len(edge_pot_list1) != 2:  
                    edge_pot_list = edge_pot_list + edge_pot_list1  
                    contour_list = contour_list + contour_list1  
        return len(edge_pot_list), edge_pot_list, edge, contour_list  
    frame_pot_list = FramePotList(edge, broad_range, 1)  
    while True:  
        edge_pot_num, edge_3pot_list, edge, contour_list = POI_for_Intersection(edge)  
        chain_list = []  
        intersection_list = []  
        average_gradient_chain_same_intersection = []  
        for LineList_num in range(len(edge_3pot_list)):  
            chain, intersection = LineList(edge, contour_list[LineList_num], edge_3pot_list[LineList_num])  
            chain_list.append(chain)  
            intersection_list.append(intersection)  
        intersection_list_unique = list(np.unique(np.array(intersection_list), axis=0))  
        # print(intersection_list_unique)  
        # print(intersection_list)        for k_dbl1 in range(len(intersection_list_unique)):  
            chain_same_intersection = []  
            dis_chain_same_intersection = []  
            average_gradient_chain_same_intersection = []  
            for k_dbl2 in range(len(intersection_list)):  
                dis_intersection = abs(intersection_list_unique[k_dbl1][0] - intersection_list[k_dbl2][0]) + abs(  
                    intersection_list_unique[k_dbl1][1] - intersection_list[k_dbl2][1])  
                # print(intersection_list_unique[k_dbl1], intersection_list[k_dbl2], dis_intersection)  
                if dis_intersection <= 2:  
                    chain_same_intersection.append(chain_list[k_dbl2])  
                    # 1、距离信息输入  
                    if (edge_3pot_list[k_dbl2] == frame_pot_list).all(1).any() == True:  
                        # print(edge_3pot_list[k_dbl2])  
                        dis_chain_same_intersection.append(frame_dis_multiple * len(chain_list[k_dbl2]))  
                    else:  
                        dis_chain_same_intersection.append(len(chain_list[k_dbl2]))  
                    # 2、梯度均值输入  
                    g_sum_pot = 0  
                    # kk = np.zeros_like(edge)  
                    for pot in chain_list[k_dbl2]:  
                        g_sum_pot = g_sobel_all[pot[0], pot[1]] + g_sum_pot  
                        # kk[pot[0], pot[1]] = 255  
                    g_sum_pot = g_sum_pot/len(chain_list[k_dbl2])  
                    average_gradient_chain_same_intersection.append(g_sum_pot)  
            if len(chain_same_intersection) >= 2:  
                if method == 1:  
                    # 处理手段1：小比例距离去分叉  
                    dis_judge_1 = min(dis_chain_same_intersection)  
                    dis_chain_same_intersection1 = dis_chain_same_intersection.copy()  
                    dis_chain_same_intersection1.remove(dis_judge_1)  
                    dis_judge_2 = min(dis_chain_same_intersection1)  
  
                    if dis_judge_1 / dis_judge_2 <= 1:  # (dis_judge_1/dis_judge_2 <= 1/5 and dis_judge_1 <= 5)  
                        chain_to_delete = chain_same_intersection[  
                            np.where(np.array(dis_chain_same_intersection) == dis_judge_1)[0][0]]  
                        for pot_to_delete in chain_to_delete:  
                            edge[pot_to_delete[0], pot_to_delete[1]] = 0  
                            # cv2.circle(edge_poi, (pot_to_delete[1], pot_to_delete[0]), 1, (255, 255, 0), -1)  
                if method == 2:  
                    # 处理手段2——梯度均值判断  
                    dis_judge_1 = min(average_gradient_chain_same_intersection)  
                    dis_chain_same_intersection1 = average_gradient_chain_same_intersection.copy()  
                    dis_chain_same_intersection1.remove(dis_judge_1)  
                    dis_judge_2 = min(dis_chain_same_intersection1)  
  
                    if dis_judge_1 / dis_judge_2 <= 1:  # (dis_judge_1/dis_judge_2 <= 1/5 and dis_judge_1 <= 5)  
                        chain_to_delete = chain_same_intersection[  
                            np.where(np.array(average_gradient_chain_same_intersection) == dis_judge_1)[0][0]]  
                        for pot_to_delete in chain_to_delete:  
                            edge[pot_to_delete[0], pot_to_delete[1]] = 0  
                if method == 3:  
                    # 处理手段3——方向  
                    dis_judge_1 = min(dis_chain_same_intersection)  
                    dis_chain_same_intersection1 = dis_chain_same_intersection.copy()  
                    dis_chain_same_intersection1.remove(dis_judge_1)  
                    dis_judge_2 = min(dis_chain_same_intersection1)  
                    if dis_judge_1 / dis_judge_2 <= 1:  # (dis_judge_1/dis_judge_2 <= 1/5 and dis_judge_1 <= 5)  
                        chain_to_delete = chain_same_intersection[np.where(np.array(dis_chain_same_intersection) == dis_judge_1)[0][0]]  
                        if len(dis_chain_same_intersection) != 3:  
                            for pot_to_delete in chain_to_delete:  
                                edge[pot_to_delete[0], pot_to_delete[1]] = 0  
                        else:  
                            right_edge1 = edge.copy()  
                            for pot_to_delete in chain_to_delete:  
                                right_edge1[pot_to_delete[0], pot_to_delete[1]] = 0  
                            contours_right_edge1_pn, hierarchy_right_edge1_pn = cv2.findContours(right_edge1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                            pn_right_edge1, g_right_edge_list, pot_list_g_right_edge, chain_right_edge = GraJudge(contours_right_edge1_pn[0], right_edge1, gy, gx, g_bro)  
                            if pn_right_edge1 < 0.95:  
                                chain_to_delete = chain_same_intersection[np.where(np.array(dis_chain_same_intersection) == dis_judge_2)[0][0]]  
                                right_edge2 = edge.copy()  
                                for pot_to_delete in chain_to_delete:  
                                    right_edge2[pot_to_delete[0], pot_to_delete[1]] = 0  
                                contours_right_edge2_pn, hierarchy_right_edge2_pn = cv2.findContours(right_edge2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                                pn_right_edge2, g_right_edge_list, pot_list_g_right_edge, chain_right_edge = GraJudge(contours_right_edge2_pn[0], right_edge2, gy, gx, g_bro)  
                                if pn_right_edge2 < 0.95:  
                                    edge = right_edge1  
                                else:  
                                    edge = right_edge2  
                            else:  
                                edge = right_edge1  
                    break  
        edge_pot_num, edge_3pot_list, edge, contour_list = POI_for_Intersection(edge)  
        if edge_pot_num == 0:  
            break  
    return edge  
def FindMissinfHole(img_original_gray, mask, broad_range, y_ori, x_ori):  
    def Corrct_Hole(img, mask, method):  
        hist = cv2.calcHist([img], [0], mask, [256], [0, 256])  # hist是256x1的数组，每个值对应于该图像中具有相应像素值的像素数  
        min_gray = 0  
        for gra_num in range(256):  
            if hist[gra_num] != 0:  
                min_gray = gra_num  
                break  
        x = np.arange(256)  
        hist = hist.flatten()  # 列向量变数组  
        y = np.array(hist)  
        y = y.astype(int)  
  
        # 直方图滤波  
        y_01 = np.arange(256)  
        co_cal = [1 / 16, 1 / 16, 1 / 8, 1 / 4, 0, 1 / 4, 1 / 8, 1 / 16, 1 / 16]  
        for i in x:  
            if i <= 4:  
                la = i  
            else:  
                la = 4  
            if i + 4 >= 255:  
                rb = 255 - i  
            else:  
                rb = 4  
            y_01[i] = sum(co_cal[4 - la:4 + rb + 1] * y[i - la:i + rb + 1])  
            if i == 255:  
                break  
        y_01[0] = int(0.5 * y[0]) + y_01[0]  
        y_01[255] = int(0.5 * y[255]) + y_01[255]  
        if method == 1:  
            plt.bar(x, y_01)  
            plt.show()  
        range1 = 8  # 为了减少极值点个数，要求该点是rang1+range2内的最大值，需要尝试确定一下  
        range2 = 8  
        m = 0  # 峰值个数  
        T1 = np.arange(120)  
        for j in x:  
            if j <= range1:  
                a = j  
            else:  
                a = range1  
            if j + range2 >= 255:  
                b = 255 - j  
            else:  
                b = range2  
            z = y_01[j - a:j + b + 1]  
            if cv2.countNonZero(y_01) == 0:  
                min_y_01 = sum(y_01)  
            else:  
                min_y_01 = sum(y_01) / cv2.countNonZero(y_01)  
            if y_01[j] == np.max(z) and y_01[j] >= y_01[j + 1] and y_01[j] >= y_01[j - 1] and y_01[j] > min_y_01:  
                if m >= 1 and abs(T1[m - 1] - j) > np.max([a, b]):  
                    # 峰值条件：（1）极值（2）range1+range2内的最大值且只取一个（3）所占像素大于总像素的0.2%  
                    T1[m] = j  
                    m = m + 1  
                if m == 0:  
                    T1[m] = j  
                    m = m + 1  
            if j == 254:  
                break  
        T = T1[0:m]  
        T = T.flatten()  
        if method == 2:  
            if len(T) == 0:  
                T = np.array([10])  
                print('找不出峰值')  
            else:  
                if T[0] > 15:  
                    T = np.array([15])  
                    print('内部有问题')  
        return T  
    def Water(sfb, unknown, imgin):  
        img_show = imgin.copy()  
        sbb_water = np.zeros_like(sfb)  
        ret, markers = cv2.connectedComponents(sfb)  
        # Add one to all labels so that sure background is not 0, but 1  
        markers = markers + 1  
        # Now, mark the region of unknown with zero  
        markers[unknown == 255] = 0  
        markers_copy = markers.copy()  
        markers_0 = markers.copy()  
        markers_copy[markers == 0] = 150  # 灰色表示背景  
        markers_copy[markers == 1] = 0  # 黑色表示背景  
        markers_copy[markers > 1] = 255  # 白色表示前景  
        markers_copy = np.uint8(markers_copy)  
        # 使用分水岭算法执行基于标记的图像分割，将图像中的对象与背景分离  
        markers = cv2.watershed(imgin, markers)  
        img_show[markers == 1] = [0, 255, 255]  
        sbb_water[markers == 1] = [255]  
        # cv2.imshow(str(num0) + 'img_show', img_show)  
        # cv2.imshow(str(num0) + 'markers_copy', markers_copy)        # cv2.waitKey(0)        # cv2.destroyAllWindows()        return sbb_water  
    img_original_blur = cv2.cvtColor(img_original_gray, cv2.COLOR_BGR2GRAY)  
    img_original_blur = cv2.medianBlur(img_original_blur, 3)  
    img_original_blur = cv2.GaussianBlur(img_original_blur, (3, 3), 0, 0)  
    black_peak_mask = cv2.bitwise_and(cv2.bitwise_not(mask), cv2.morphologyEx(mask, cv2.MORPH_DILATE, np.ones((11, 11), np.uint8)))  
    T_list = Corrct_Hole(img_original_blur, black_peak_mask, method=2)  
    T = T_list[0]  
    u0 = np.sum(cv2.bitwise_and(img_original_blur, cv2.bitwise_not(mask))) / cv2.countNonZero(cv2.bitwise_and(img_original_blur,  cv2.bitwise_not(mask)))  
    u1 = np.sum(cv2.bitwise_and(img_original_blur, mask)) / cv2.countNonZero(cv2.bitwise_and(img_original_blur, mask))  
    tl = 0.726*(u1-u0)  
    th = 3*tl  
    g_img, tl_gra, th_gra = Gra(img_original_blur, tl, th)  
    tl_gra, g_ret_low = cv2.threshold(g_img, tl_gra, 255, cv2.THRESH_BINARY)  
    img_original_gray_border = cv2.copyMakeBorder(img_original_blur, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=u1)  
    g_img1, tl_gra1, th_gra1 = Gra(img_original_gray_border, tl, th)  
    g_img1 = g_img1[broad_range:y_ori+broad_range, broad_range:x_ori+broad_range]  
    for c in contour_mask_1:  
        mask_judge = np.zeros_like(mask)  
        cv2.drawContours(mask_judge, [c], -1, [255], -1)  
        cv2.drawContours(mask_judge, [c], -1, [0], 1)  
        mask_judge = cv2.bitwise_and(mask_judge, mask)  
        judge_1_img = cv2.bitwise_and(mask_judge, img_original_blur)  
        T, judge_1_img_thresh = cv2.threshold(judge_1_img, T, 255, cv2.THRESH_BINARY)  
        # judge_g_thresh = cv2.morphologyEx(judge_1_img_thresh, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))  
        judge_g_thresh = cv2.bitwise_xor(judge_1_img_thresh, mask_judge)  
        judge_g_thresh = cv2.morphologyEx(judge_g_thresh, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))  
        judge_g_thresh = cv2.morphologyEx(judge_g_thresh, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
        sbb = judge_g_thresh.copy()  
        judge_g_thresh = cv2.bitwise_and(judge_g_thresh, g_ret_low)  
        if cv2.countNonZero(judge_g_thresh) > 0:  
            # print(str(num0), cv2.countNonZero(judge_g_thresh), max)  
            ret_sfb, sfb = cv2.threshold(judge_1_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)  
            sfb = cv2.morphologyEx(sfb, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))  
            sfb = cv2.morphologyEx(sfb, cv2.MORPH_ERODE, np.ones((3, 3), np.uint8))  
            unknown = cv2.subtract(mask_judge, sfb)  
            unknown = cv2.subtract(unknown, sbb)  
            sbb_new = Water(sfb, unknown, img_original)  
            sbb_new = cv2.bitwise_and(mask_judge, sbb_new)  
            sbb_new = cv2.morphologyEx(sbb_new, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))  
            contour_sbb_new, hierarchy_sbb_new = cv2.findContours(sbb_new, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
            for c_sbb in contour_sbb_new:  
                sbb_g = np.zeros_like(sbb_new)  
                cv2.drawContours(sbb_g, [c_sbb], -1, [255], 1)  
                max_g = np.max(cv2.bitwise_and(sbb_g, g_img))  
                g_avr = cv2.bitwise_and(sbb_g, g_img1)  
                g_avr_num = np.sum(g_avr) / cv2.countNonZero(g_avr)  
                cv2.drawContours(sbb_g, [c_sbb], -1, [255], -1)  
                u_avr = cv2.bitwise_and(sbb_g, img_original_blur)  
                u_avr_num = np.sum(u_avr) / cv2.countNonZero(u_avr)  
                # print(num0, '梯度均值', g_avr_num, '灰度均值', u_avr_num, '梯度最大值', max_g, '低梯度阈值', tl_gra, T)  
                if (max_g >= 2*tl_gra and (g_avr_num > tl_gra or u_avr_num < 1.5*T)) or max_g >= 2.5*tl_gra:  
                    mask_subtract = np.zeros_like(mask)  
                    mask_subtract = cv2.drawContours(mask_subtract, [c_sbb], -1, [255], -1)  
                    mask_subtract = cv2.copyMakeBorder(mask_subtract[1:y_ori-1, 1:x_ori-1], 1, 1, 1, 1, cv2.BORDER_REPLICATE)  
                    mask = cv2.bitwise_xor(mask, mask_subtract)  
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))  
    return mask  
image = ('image_path')  
imgin = cv2.imread(image)  
img_original = imgin.copy()  # 原图->data  
img_original_gray = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)  
open_edge_num = 0  # 断开开线段条数->data  
gray_u_all = np.sum(img_original_gray) / cv2.countNonZero(img_original_gray)  # 原图的灰度均值->data  
y_ori, x_ori, c_ori = imgin.shape  # 图像尺寸->data  
broad_range = 30  # 扩充边界的宽度->data  
imgin = cv2.copyMakeBorder(imgin, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_REPLICATE)  
img = cv2.cvtColor(imgin, cv2.COLOR_BGR2GRAY)  
img_gray_ori = img[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori]  
y, x = img.shape  
area_all = y*x  
edge_all, g_img, g_ret_low, g_ret_high, ret_all_dia, img_blur = OriEdge(img, broad_range, y_ori, x_ori)  # 0:03:00.413964  
contour_all01, edge_all01 = DivideCE(edge_all)  
# # 连接小的断裂  
edge_all01 = ConnectClosePot(edge_all01, broad_range, 1)  
edge_all01 = ConnectEdgepotOnSameContour(edge_all01, 4)  
# # 再次把闭合线段和开线段的分开，得到闭合轮廓和开线段  
contour_all02, edge_all02 = DivideCE(edge_all01)  
contour = cv2.add(contour_all01, contour_all02)  
strong_edge = contour.copy()  
contour = contour[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori]  
contour = DeleteSmallEdge0(contour, 10)  
edge = edge_all02  
  
# 去除分叉  
edge = DeleteBifurcationLine(edge, broad_range, frame_dis_multiple=1)  
frame_edge, edge, edge_add = FrameEdge(edge, broad_range, 2)  
all_frame_edge = cv2.add(frame_edge, edge_add)[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori]  
  
# 修正切割多边形和删去小线段  
edge = DeleteLowGraEdge(edge, g_ret_high)  
edge = cv2.subtract(edge, ret_all_dia)  
edge = DeleteSmallEdge0(edge, min_len=20)  
  
# 分水岭连接大断裂  
contour_wide_open = WaterEdge(edge, img, imgin, area_all, open_edge_num, initial_median_col=3, max_median_col=21, ksize=5)  
contour_wide_open1 = np.zeros_like(contour_wide_open)
  
# 初始结果  
img_ori = img_original.copy()  
ero_judge = cv2.morphologyEx(edge[broad_range:broad_range+y_ori, broad_range:broad_range+x_ori], cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
contour_wide_open1 = np.zeros_like(ero_judge)  
contours, hierarchy = cv2.findContours(contour_wide_open[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori], cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
for c in contours:  
    test_contour = np.zeros_like(ero_judge)  
    cv2.drawContours(test_contour, c, -1, [255, 255, 255], 1)  
    if cv2.countNonZero(cv2.bitwise_and(ero_judge, test_contour)) != 0:  
        cv2.drawContours(img_ori, c, -1, [0, 255, 0], -1)  
        cv2.drawContours(contour_wide_open1, c, -1, [255, 255, 255], 1)  
img_ori[frame_edge[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori] == 255] = [0, 120, 255]  
img_ori[edge_add[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori] == 255] = [0, 0, 255]  
img_ori[contour == 255] = [255, 0, 255]  
# 报错判断  
img_ori1 = img_original.copy()  
frame_edge_dia = cv2.morphologyEx(all_frame_edge, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
contour_dia = cv2.morphologyEx(contour, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
error_judge1_img_plus = cv2.bitwise_and(contour_wide_open1, frame_edge_dia)  
error_judge2_img_plus = cv2.bitwise_and(contour_wide_open1, contour_dia)  
error_judge_1 = cv2.countNonZero(error_judge1_img_plus)  
error_judge_2 = cv2.countNonZero(error_judge2_img_plus)  
contour_wide_open_connect = np.zeros_like(contour_wide_open1)  
g_bro = 3  
gx = cv2.Sobel(img_blur[broad_range - g_bro:broad_range + y_ori + g_bro, broad_range - g_bro:broad_range + x_ori + g_bro], cv2.CV_32F, 1, 0, ksize=(2 * g_bro + 1))  # 水平梯度  
gy = cv2.Sobel(img_blur[broad_range - g_bro:broad_range + y_ori + g_bro, broad_range - g_bro:broad_range + x_ori + g_bro], cv2.CV_32F, 0, 1, ksize=(2 * g_bro + 1))  # 竖直梯度  
g_sobel_all = abs(gx) + abs(gy)  
edge_part = edge[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori]  
# 错误处理，得到尽可能对的contour_wide_open_connect  
if error_judge_1 != 0 or error_judge_2 != 0:  
    img_ori1[frame_edge[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori] == 255] = [0, 120, 255]  
    img_ori1[edge_add[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori] == 255] = [0, 0, 255]  
    img_ori1[contour == 255] = [255, 0, 255]  
    cor_edge = contour_wide_open1.copy()  
    cor_edge = DeleteBifurcationLine(cor_edge, 0, frame_dis_multiple=10)  
    contours_cor, hierarchy_cor = cv2.findContours(cor_edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    contours_edge, hierarchy_edge = cv2.findContours(edge_part, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
    for c_cor in contours_cor:  
        cor_edge_delete = cor_edge  
        test_cor = np.zeros_like(ero_judge)  
        cv2.drawContours(test_cor, c_cor, -1, [255, 255, 255], 1)  
        cv2.drawContours(cor_edge_delete, c_cor, -1, [0], 2)  
        cor_edge_delete  
        if len(c_cor) > 4:  
            if (cv2.countNonZero(cv2.bitwise_and(test_cor, frame_edge_dia)) > 0 or cv2.countNonZero(cv2.bitwise_and(test_cor, contour_dia)) > 0):  
                edge_water_aga = np.zeros_like(ero_judge)  
                c_dinum = 0  
                for c_edge in contours_edge:  
                    edge_aga = np.zeros_like(ero_judge)  
                    cv2.drawContours(edge_aga, c_edge, -1, [255, 255, 255], 1)  
                    edge_aga_dia = cv2.morphologyEx(edge_aga, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
                    if cv2.countNonZero(cv2.bitwise_and(test_cor, edge_aga_dia)) > 0:  
                        c_dinum = c_dinum + 1  
                        edge_water_aga = cv2.add(edge_water_aga, edge_aga)  
                if c_dinum > 0:  
                    edge_water_aga = cv2.copyMakeBorder(edge_water_aga, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
                    initial_median_col = 3  
                    max_median_col = 15  
                    code_judge = 0  
                    while True:  
                        contour_wide_open_aga = WaterEdge1(edge_water_aga, img, imgin, col=initial_median_col, ksize=5)[broad_range:broad_range + y_ori,  
                                                broad_range:broad_range + x_ori]  
                        contours_aga, hierarchy_aga = cv2.findContours(contour_wide_open_aga, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                        if (cv2.countNonZero(cv2.bitwise_and(contour_wide_open_aga, frame_edge_dia)) == 0 and cv2.countNonZero(cv2.bitwise_and(contour_wide_open_aga, contour_dia)) == 0):  
                            break  
                        elif initial_median_col == max_median_col:  
                            code_judge = 1  
                            break  
                        initial_median_col = initial_median_col + 2  
                    if code_judge == 0 and cv2.countNonZero(cv2.bitwise_and(contour_wide_open_aga, cor_edge_delete)) == 0:  
                        img_ori1[contour_wide_open_aga == 255] = [0, 255, 0]  
                        contour_wide_open_connect[contour_wide_open_aga == 255] = [255]  
                    else:  
                        cv2.drawContours(img_ori1, c_cor, -1, [0, 255, 0], -1)  
                        cv2.drawContours(contour_wide_open_connect, c_cor, -1, [255], 1)  
            else:  
                cv2.drawContours(img_ori1, c_cor, -1, [0, 255, 0], -1)  
                cv2.drawContours(contour_wide_open_connect, c_cor, -1, [255], 1)  
else:  
    contour_wide_open_connect = contour_wide_open1  
    img_ori1 = img_ori  
  
  
# 处理edge重合  
img_ori2 = img_original.copy()  
frame_pot_all_list = FramePotAllList(y_ori, x_ori)  
u_img_ori = np.sum(img_gray_ori) / cv2.countNonZero(img_gray_ori)  
contour_wide_open_connect = Skeletonize(contour_wide_open_connect)  
contour_from_edge, contour_wide_open_connect = DivideCE(contour_wide_open_connect)  
contour_wide_open_connect = ConnectClosePot(contour_wide_open_connect, 0, 2)  
contour_wide_open_connect = DeleteLowGraEdge(contour_wide_open_connect, g_ret_high[broad_range:broad_range + y_ori, broad_range:broad_range + x_ori])  
error_judge3 = cv2.bitwise_and(contour_wide_open_connect, all_frame_edge)  
contour_final = cv2.add(contour, contour_from_edge)  
contour_wide_open_final = np.zeros_like(contour)  
all_frame_edge_final = np.zeros_like(contour)  
if cv2.countNonZero(error_judge3) > 0:  
    img_ori2[contour == 255] = [255, 0, 255]  
    img_ori2[contour_from_edge == 255] = [255, 0, 255]  
    contours_f, hierarchy_f = cv2.findContours(all_frame_edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    contours_e, hierarchy_e = cv2.findContours(contour_wide_open_connect, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
    for c_e in contours_e:  
        test_e = np.zeros_like(contour_wide_open_connect)  
        cv2.drawContours(test_e, c_e, -1, [255, 255, 255], 1)  
        if cv2.countNonZero(cv2.bitwise_and(test_e, all_frame_edge)) > 0 and len(c_e) >= cv2.contourArea(c_e):  
            for c_f in contours_f:  
                test_f = np.zeros_like(all_frame_edge)  
                cv2.drawContours(test_f, c_f, -1, [255, 255, 255], 1)  
                if cv2.countNonZero(cv2.bitwise_and(test_f, test_e)) > 0:  
                    right_edge = np.zeros_like(test_e)  
                    epn_e, epl_e, test_e = POI(test_e)  
                    epn_f, epl_f, test_f = POI(test_f)  
                    if len(epl_e) != 2 or len(epl_e) != 2:  
                        if len(epl_e) != 2:  
                            test_e = DeleteBifurcationLine(test_e, 0, frame_dis_multiple=10)  
                            c_e, hierarchy_c_e = cv2.findContours(test_e, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
                            c_e = c_e[0]  
                            epn_e, epl_e, test_e = POI(test_e)  
                        if len(epl_f) != 2:  
                            test_f = DeleteBifurcationLine(test_f, 0, frame_dis_multiple=10)  
                            c_f, hierarchy_c_f = cv2.findContours(test_f, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
                            c_f = c_f[0]  
                            epn_f, epl_f, test_f = POI(test_f)  
                    if len(epl_e) == 2 and len(epl_e) == 2:  
                        pn_e, g_list_e, pot_list_ge, chain_e = GraJudge(c_e, test_e, gy, gx, g_bro)  
                        pn_f, g_list_f, pot_list_gf, chain_f = GraJudge(c_f, test_f, gy, gx, g_bro)  
                        epl_e[0] = POStoFrame(pot_list_ge[0], y_ori, x_ori)  
                        epl_e_num0 = POStoNUM(pot_list_ge[0], y_ori, x_ori)  
                        epl_e[1] = POStoFrame(pot_list_ge[1], y_ori, x_ori)  
                        epl_e_num1 = POStoNUM(pot_list_ge[1], y_ori, x_ori)  
                        epl_f[0] = POStoFrame(pot_list_gf[0], y_ori, x_ori)  
                        epl_f_num0 = POStoNUM(pot_list_gf[0], y_ori, x_ori)  
                        epl_f[1] = POStoFrame(pot_list_gf[1], y_ori, x_ori)  
                        epl_f_num1 = POStoNUM(pot_list_gf[1], y_ori, x_ori)  
                        pp = min(epl_e_num0, epl_e_num1)-min(epl_f_num0, epl_f_num1)  
                        ap = max(epl_e_num0, epl_e_num1)-max(epl_f_num0, epl_f_num1)  
                        if abs(pp) <= 3 and abs(ap) <= 3:  
                            right_edge = test_f  
                            print('重合+去看被湮灭的开线段')  
                        else:  
                            pn_e, g_list_e, pot_list_ge, chain_ge = GraJudge(c_e, test_e, gy, gx, g_bro)  
                            pn_f, g_list_f, pot_list_gf, chain_gf = GraJudge(c_f, test_f, gy, gx, g_bro)  
                            ge04 = sum(g_list_e[0:4])  
                            ge40 = sum(g_list_e[len(g_list_e) - 5:len(g_list_e) - 1])  
                            gf04 = sum(g_list_f[0:4])  
                            gf40 = sum(g_list_f[len(g_list_f) - 5:len(g_list_f) - 1])  
                            if ge04*ge40 > 0 and gf04*gf40 > 0:  
                                right_edge = cv2.add(test_f, test_e)  
                                contours_right_edge, hierarchy_right_edge = cv2.findContours(right_edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                                cv2.drawContours(right_edge, contours_right_edge, -1, [255, 255, 255], -1)  
                                right_edge = Skeletonize(right_edge)  
                                epn_right_edge, epl_right_edge, right_edge = POI(right_edge)  
                                if epn_right_edge != 2:  
                                    right_edge1 = right_edge.copy()  
                                    right_edge1 = DeleteBifurcationLine(right_edge1, 0, frame_dis_multiple=1)  
                                    contours_right_edge_pn, hierarchy_right_edge_pn = cv2.findContours(right_edge1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
                                    pn_right_edge, g_right_edge_list, pot_list_g_right_edge, chain_right_edge = GraJudge(contours_right_edge_pn[0], right_edge1, gy, gx, g_bro)  
                                    if pn_right_edge < 0.95:  
                                        print('出现一条方向不一致的线+去看该线')  
                                        right_edge1 = right_edge.copy()  
                                        right_edge1 = DeleteBifurcationLineG(right_edge1, g_sobel_all, broad_range, gy, gx, g_bro, frame_dis_multiple=1, method=3)  
                                        right_edge = right_edge1  
                                    else:  
                                        right_edge = right_edge1  
                            else:  
                                if ge04*ge40 < 0 and gf04*gf40 > 0:  
                                    right_edge = test_f  
                                elif ge04 * ge40 > 0 and gf04 * gf40 < 0:  
                                    right_edge = test_e  
                                else:  
                                    print('两条重合的线方向都不一致')  
                    else:  
                        print('出现connnect上有三个点')  
                    img_ori2[right_edge == 255] = [120, 255, 0]  
                    contour_wide_open_final[right_edge == 255] = [255]  
                if cv2.countNonZero(cv2.bitwise_and(test_f, contour_wide_open_connect)) == 0:  
                    cv2.drawContours(img_ori2, c_f, -1, [0, 120, 255], 1)  
                    cv2.drawContours(all_frame_edge_final, c_f, -1, [255, 255, 255], 1)  
        else:  
            cv2.drawContours(img_ori2, c_e, -1, [0, 255, 0], 1)  
            cv2.drawContours(contour_wide_open_final, c_e, -1, [255, 255, 255], 1)  
else:  
    img_ori2 = img_ori1  
    all_frame_edge_final = all_frame_edge  
    contour_wide_open_final = contour_wide_open_connect  
# 终极识别  
error_judge_final = cv2.bitwise_and(contour_wide_open_final, all_frame_edge_final)  
contour_all_final = cv2.add(contour_final, all_frame_edge_final)  
contour_all_final = cv2.add(contour_all_final, contour_wide_open_final)  
if cv2.countNonZero(error_judge_final) > 0:  
    print('还是重合')  
# 得到轮廓数据和mask  
mask = np.zeros_like(contour)  
# 处理frame和edge的  
img_ori3 = img_original.copy()  
img_ori3 = cv2.copyMakeBorder(img_ori3, broad_range, broad_range, broad_range, broad_range, cv2.BORDER_CONSTANT, value=0)  
img_ori3_gray = cv2.cvtColor(img_ori3, cv2.COLOR_BGR2GRAY)  
img_ori3_gray = cv2.medianBlur(img_ori3_gray, 3)  
img_ori3_gray = cv2.GaussianBlur(img_ori3_gray, (3, 3), 0, 0)  
gx_border = cv2.Sobel(img_ori3_gray[broad_range - g_bro:broad_range + y_ori + g_bro, broad_range - g_bro:broad_range + x_ori + g_bro], cv2.CV_32F, 1, 0, ksize=(2 * g_bro + 1))  # 水平梯度  
gy_border = cv2.Sobel(img_ori3_gray[broad_range - g_bro:broad_range + y_ori + g_bro, broad_range - g_bro:broad_range + x_ori + g_bro], cv2.CV_32F, 0, 1, ksize=(2 * g_bro + 1))  # 竖直梯度  
starting_point_list = []  
end_point_list = []  
part_chain_list = []  
contours_frame, hierarchy_frame = cv2.findContours(all_frame_edge_final, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
contours_wide_open, hierarchy_wide_open = cv2.findContours(contour_wide_open_final, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
contours_edge = contours_frame+contours_wide_open  
for c_edge in contours_edge:  
    edge_test = np.zeros_like(all_frame_edge_final)  
    cv2.drawContours(edge_test, [c_edge], -1, [255], 1)  
    pn_frame_test, g_list_frame_test, pot_list_g_frame_test, chain_frame_test = GraJudge(c_edge, edge_test, gy, gx, g_bro)  
    sp_ori = pot_list_g_frame_test[0].copy()  
    ep_ori = pot_list_g_frame_test[1].copy()  
    sp = POStoNUM(POStoFrame(pot_list_g_frame_test[0], y_ori, x_ori), y_ori, x_ori)  
    ep = POStoNUM(POStoFrame(pot_list_g_frame_test[1], y_ori, x_ori), y_ori, x_ori)  
    if (sp_ori == pot_list_g_frame_test[0]).all() == False or (ep_ori == pot_list_g_frame_test[1]).all() == False:  
        if (sp_ori == pot_list_g_frame_test[0]).all() == False:  
            cv2.line(edge_test, (sp_ori[1], sp_ori[0]), (pot_list_g_frame_test[0][1], pot_list_g_frame_test[0][0]), (255, 255, 255), 1)  
        if (ep_ori == pot_list_g_frame_test[1]).all() == False:  
            cv2.line(edge_test, (ep_ori[1], ep_ori[0]), (pot_list_g_frame_test[1][1], pot_list_g_frame_test[1][0]), (255, 255, 255), 1)  
        pn_frame_test, g_list_frame_test, pot_list_g_frame_test, chain_frame_test = GraJudge(c_edge, edge_test, gy, gx, g_bro)  
    if sp != 2 * (y_ori + x_ori) and ep != 2 * (y_ori + x_ori):  
        if sum(g_list_frame_test) < 0:  
            part_chain_list.append(np.flip(np.array(chain_frame_test), 0))  
            end_point_list.append(sp)  
            starting_point_list.append(ep)  
        else:  
            part_chain_list.append(chain_frame_test)  
            end_point_list.append(ep)  
            starting_point_list.append(sp)  
    else:  
        print('出现两端不在border上的线段')  
mask = np.zeros_like(contour_wide_open_final)  
mask1 = np.zeros_like(contour_wide_open_final)  
mask0 = np.zeros_like(contour_wide_open_final)  
mask_judge = 1  
while len(end_point_list) != 0:  
    mask_1 = np.zeros_like(contour_wide_open_final)  
    mask_0 = np.zeros_like(contour_wide_open_final)  
    new_end_point_list = []  
    new_starting_point_list = []  
    new_part_chain_list = []  
    mask_judge = mask_judge * -1  
    # print(end_point_list)  
    # print(starting_point_list)    for es_point_num in range(len(end_point_list)):  
        end_point = end_point_list[es_point_num]  
        mask_min = np.zeros_like(all_frame_edge_final)  
        start_point = starting_point_list[es_point_num]  
        incre = 0  
        times = 0  
        stop_judge = 0  
        line_add_2_list = []  
        while True:  
            line_add_2_list.append(frame_pot_all_list[end_point + incre])  
            if (end_point + incre in starting_point_list) == True:  
                start_point_ccw = end_point + incre  
                break  
            if end_point + incre == 0:  
                incre = len(frame_pot_all_list) - end_point  
            if times == len(frame_pot_all_list) - 1:  
                incre = - end_point  
                stop_judge = 1  
                break  
            incre = incre - 1  
            times = times + 1  
        if start_point_ccw == start_point:  
            for pot in part_chain_list[es_point_num]:  
                mask_min[pot[0], pot[1]] = 255  
            for pot in line_add_2_list:  
                mask_min[pot[0], pot[1]] = 255  
            mask_min = Maks_min(mask_min)  
            mask_1 = cv2.add(mask_1, mask_min)  
        else:  
            incre = 0  
            times = 0  
            stop_judge = 0  
            line_add_1_list = []  
            while True:  
                # print(num_se + incre, num_se+incre in end_point_list)  
                line_add_1_list.append(frame_pot_all_list[end_point + incre])  
                if (end_point + incre in starting_point_list) == True:  
                    start_point_cw = end_point + incre  
                    break  
                if end_point + incre == len(frame_pot_all_list) - 1:  
                    incre = - end_point  
                if times == len(frame_pot_all_list) - 1:  
                    incre = - end_point  
                    stop_judge = 1  
                    break  
                incre = incre + 1  
                times = times + 1  
            if start_point_cw == start_point:  
                for pot in line_add_1_list:  
                    mask_min[pot[0], pot[1]] = 255  
                for pot in part_chain_list[es_point_num]:  
                    mask_min[pot[0], pot[1]] = 255  
                mask_min = Maks_min(mask_min)  
                mask_0 = cv2.add(mask_0, mask_min)  
            else:  
                new_end_point_list.append(end_point)  
                new_starting_point_list.append(start_point)  
                new_part_chain_list.append(part_chain_list[es_point_num])  
    mask1 = cv2.bitwise_xor(mask1, mask_0)  
    mask0 = cv2.bitwise_xor(mask0, mask_1)  
    starting_point_list = new_starting_point_list  
    end_point_list = new_end_point_list  
    part_chain_list = new_part_chain_list  
mask = cv2.bitwise_xor(mask0, mask1)  
gray_mask = np.sum(cv2.bitwise_and(mask, img_original_gray))/cv2.countNonZero(cv2.bitwise_and(mask, img_original_gray))  
if gray_mask < gray_u_all:  
    mask = cv2.bitwise_not(mask)  
# 已经闭合的  
contours_contour3, hierarchy_contour3 = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
contour_border = np.zeros_like(contour_wide_open_final)  
cv2.drawContours(contour_border, contours_contour3, -1, [255], 1)  
cv2.drawContours(mask, contours_contour3, -1, [255], -1)  
all_contour = cv2.add(contour, contour_from_edge)  
if cv2.countNonZero(cv2.bitwise_and(all_contour, contour_border)) != 0:  
    print('border contour重合')  
contours_contour1, hierarchy_contour1 = cv2.findContours(contour, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)  
contours_contour2, hierarchy_contour2 = cv2.findContours(contour_from_edge, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)  
connect_area = np.zeros_like(contour_from_edge)  
for c1_num in range(len(contours_contour1)):  
    if hierarchy_contour1[0][c1_num][3] == -1:  
        c1_line = np.zeros_like(contour_from_edge)  
        c1_area = np.zeros_like(contour_from_edge)  
        cv2.drawContours(c1_line, [contours_contour1[c1_num]], -1, [255], 1)  
        cv2.drawContours(c1_area, [contours_contour1[c1_num]], -1, [255], -1)  
        if cv2.countNonZero(cv2.bitwise_and(c1_line, contour_from_edge)) == 0:  
            mask = cv2.bitwise_xor(c1_area, mask)  
        else:  
            connect_area = cv2.add(connect_area, c1_area)  
for c1_num in range(len(contours_contour2)):  
    if hierarchy_contour2[0][c1_num][3] == -1:  
        c1_line = np.zeros_like(contour_from_edge)  
        c1_area = np.zeros_like(contour_from_edge)  
        cv2.drawContours(c1_line, [contours_contour2[c1_num]], -1, [255], 1)  
        cv2.drawContours(c1_area, [contours_contour2[c1_num]], -1, [255], -1)  
        if cv2.countNonZero(cv2.bitwise_and(c1_line, contour)) == 0:  
            mask = cv2.bitwise_xor(c1_area, mask)  
        else:  
            connect_area = cv2.add(connect_area, c1_area)  
contours_contour3, hierarchy_contour3 = cv2.findContours(connect_area, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
for c1_num in range(len(contours_contour3)):  
    c1_area = np.zeros_like(contour_from_edge)  
    cv2.drawContours(c1_area, [contours_contour3[c1_num]], -1, [255], -1)  
    mask = cv2.subtract(mask, c1_area)  
    ret_c1_area, c1_area = cv2.threshold(cv2.bitwise_and(c1_area, img_original_gray), 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)  
    c1_area = cv2.morphologyEx(c1_area, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))  
    c1_area = cv2.morphologyEx(c1_area, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))  
    mask = cv2.bitwise_xor(c1_area, mask)  
  
# 反相判断  
contour_mask_1, hierarchy_mask_1 = cv2.findContours(mask, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)  
for c_mask_1_num in range(len(contour_mask_1)):  
    if hierarchy_mask_1[0][c_mask_1_num][3] == -1 and len(contour_mask_1[c_mask_1_num]) > 10:  
        mask_judge0 = np.zeros_like(mask)  
        mask_judge = np.zeros_like(mask)  
        mask_judge1 = np.zeros_like(mask)  
        cv2.drawContours(mask_judge, [contour_mask_1[c_mask_1_num]], -1, [255], -1)  
        cv2.drawContours(mask_judge0, [contour_mask_1[c_mask_1_num]], -1, [255], -1)  
        cv2.drawContours(mask_judge1, [contour_mask_1[c_mask_1_num]], -1, [255], 1)  
        mask_judge0 = cv2.bitwise_and(mask_judge0, mask)  
        contour_not_connected, hierarchy_not_connected = cv2.findContours(mask_judge0, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
        for c_n_c in contour_not_connected:  
            mask_judge_c_n_c = np.zeros_like(mask)  
            cv2.drawContours(mask_judge_c_n_c, c_n_c, -1, [255], 1)  
            if cv2.countNonZero(cv2.bitwise_and(mask_judge_c_n_c, mask_judge1)) == 0:  
                mask_judge = cv2.drawContours(mask_judge, [c_n_c], -1, [0], -1)  
        if cv2.countNonZero(mask_judge) != 0:  
            judge_1_img = cv2.bitwise_and(mask_judge, img_original_gray)  
            gray_mask_judge = np.sum(judge_1_img) / cv2.countNonZero(cv2.bitwise_and(mask_judge, img_original_gray))  
            if gray_mask_judge < 0.7*gray_u_all:  
                print('实体———>孔')  
                mask[mask_judge == 255] = 0  
mask_not = cv2.bitwise_not(mask)  
contour_mask_0, hierarchy_mask_0 = cv2.findContours(mask_not, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)  
for c_mask_0_num in range(len(contour_mask_0)):  
    if hierarchy_mask_0[0][c_mask_0_num][3] == -1 and len(contour_mask_0[c_mask_0_num]) > 10:  
        mask_judge0 = np.zeros_like(mask)  
        mask_judge = np.zeros_like(mask)  
        mask_judge1 = np.zeros_like(mask)  
        cv2.drawContours(mask_judge, [contour_mask_0[c_mask_0_num]], -1, [255], -1)  
        cv2.drawContours(mask_judge0, [contour_mask_0[c_mask_0_num]], -1, [255], -1)  
        cv2.drawContours(mask_judge1, [contour_mask_0[c_mask_0_num]], -1, [255], 1)  
        mask_judge0 = cv2.bitwise_and(mask_judge0, mask_not)  
        contour_not_connected, hierarchy_not_connected = cv2.findContours(mask_judge0, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)  
        for c_n_c in contour_not_connected:  
            mask_judge_c_n_c = np.zeros_like(mask)  
            cv2.drawContours(mask_judge_c_n_c, c_n_c, -1, [255], 1)  
            if cv2.countNonZero(cv2.bitwise_and(mask_judge_c_n_c, mask_judge1)) == 0:  
                mask_judge = cv2.drawContours(mask_judge, [c_n_c], -1, [0], -1)  
        if cv2.countNonZero(mask_judge) != 0:  
            gray_mask_judge = np.sum(cv2.bitwise_and(mask_judge, img_original_gray)) / cv2.countNonZero(cv2.bitwise_and(mask_judge, img_original_gray))  
            if gray_mask_judge > 1.5 * gray_u_all:  
                print('孔———>实体')  
                mask[mask_judge == 255] = 255  
                mask_not[mask_judge == 255] = 0  
# 丢孔判断  
mask = FindMissinfHole(img_original, mask, broad_range, y_ori, x_ori)  
contour = np.zeros_like(mask)  
contour_mask_1, hierarchy_mask_1 = cv2.findContours(mask, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)  
cv2.drawContours(img_original, contour_mask_1, -1, [50, 255, 0], 1)  
cv2.drawContours(contour, contour_mask_1, -1, [255], 1)  
# 缺线段判断  
contour_dia = cv2.morphologyEx(contour, cv2.MORPH_DILATE, np.ones((3, 3), np.uint8))  
contours_edge_part, hierarchy_edge_part = cv2.findContours(edge_part, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  
for c_edge_part in contours_edge_part:  
    edge_aga1 = np.zeros_like(edge_part)  
    cv2.drawContours(edge_aga1, c_edge_part, -1, [255, 255, 255], 1)  
    if cv2.countNonZero(cv2.bitwise_and(edge_aga1, contour_dia)) == 0:  
        print('缺了线段')  
        cv2.drawContours(img_original, c_edge_part, -1, [0, 0, 255], 1)
```
