# 内存的变化
## 基本思想
首先的思想就是，每一个内存空间有两个属性，第一个属性是==内含物==，第二个属性是==地址==。
内含物是很容易理解的，就是这个内存里边到底存放了什么东西。地址的话，就是**该内存**的唯一的编号。
> [!question] 编号是需要储存的吗？如何通过编号检索到特定的存储单元的？
> 这里可以想象数电里边的那个四选一，传入一个地址信号，自然那条线就通电了。所以编号的存储方法也是根据特定的硬件结构固化在芯片内部的。

## 值传递
在进行值传递的时候，我们定义的函数肯定有如下的形式
`int Func(int a, int b)`
当编译器检测到传入的是**值**的时候，此函数一旦调用，就会开辟新的内存空间。假如我们传入的是值，我们实际的操作就是局部变量（栈区）的内含物变成了我们传入的值，即`a = 传入值`。但实际的参数并没有改变，因此传入一数值和传入一个参数是一样的（只要数据类型是对的）。
> [!question] 函数中的静态变量，若是此函数没有调用的话，还会开辟对应的内存吗？

> [!question] 函数传入参数的时候到底发生了什么？
> 假设以那个交换函数作为例子，则有你传入的时候其实就是**把实参的值给形参**

> [!quote] =到底是在做什么？
> 右值的内含物给到左值的内含物

## 地址传递
`int Func(int * a, int * b)`
传入的如果是c和d地址，那么之前是**数据**会传进去，传到哪？->新的内存空间。现在是**地址数据**会传进去，也是在内存空间里，但是操作的时候都是`*p`的形式进行操作的，因此会改变实参。

## 引用传递
```c++
void swap( int &p1 , int &p2) 
{
	int temp = p1;
	p1 = p2;
	p2 = temp;
	cout << "swap函数中a：" << p1 << "\ta的指针为：" << &p1 << endl;
	cout << "swap函数中b：" << p2 << "\tb的指针为：" << &p2 << endl;

}

void main()
{
	int a = 10;
	int b = 20;
	cout << "交换前：" << endl;
	cout << "a：" << a << "\ta的指针为：" << &a << endl;
	cout << "b：" << b << "\tb的指针为：" << &b << endl;
	cout << endl;
	swap( a , b);
	cout << endl;
	cout << "交换后：" << endl;
	cout << "a：" << a << "\ta的指针为：" << &a << endl;
	cout << "b：" << b << "\tb的指针为：" << &b << endl;
}
```
> 1. 传入操作：`int & p1 = a`，实际编译器进行的是：`int * const p1 = &a`
> 2. 引用赋值操作：int temp = p1 实际编译器进行的操作是int temp = \*p1
> 3. p1 = p2 ——> \*p1 = \*p2
> 4. p2 = temp ——> \*p2 = temp

